<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://zxxyy.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://zxxyy.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-09-26T06:06:39+00:00</updated><id>https://zxxyy.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Python3 Concurrency: asyncio module/async/await</title><link href="https://zxxyy.github.io/blog/2024/python-asyncio/" rel="alternate" type="text/html" title="Python3 Concurrency: asyncio module/async/await"/><published>2024-09-03T13:00:00+00:00</published><updated>2024-09-03T13:00:00+00:00</updated><id>https://zxxyy.github.io/blog/2024/python-asyncio</id><content type="html" xml:base="https://zxxyy.github.io/blog/2024/python-asyncio/"><![CDATA[<h3 id="基本概念">基本概念</h3> <ul> <li> <p><strong><code class="language-plaintext highlighter-rouge">coroutine</code></strong>: 协程可以在函数到达 <code class="language-plaintext highlighter-rouge">return</code> 之前暂停执行，并将控制权间接传递给另一个协程。</p> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">asyncio</code></strong>: 处理Python coroutine（协程）的包</p> <ul> <li>async IO is a single-threaded, single-process design: it uses <strong>cooperative multitasking</strong></li> <li>perfect for IO-bound tasks (network, disk, database)</li> <li><img src="/assets/img/in-post/2024-09-05-asyncio.png" alt="overview"/></li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">async</code>/<code class="language-plaintext highlighter-rouge">await</code></strong>: 用来定义coroutine的Python keywords</p> <ul> <li><code class="language-plaintext highlighter-rouge">await</code>: 将函数控制权交还给事件循环，并且可以执行其他操作 <ul> <li>只能在coroutine中使用await，否则报错<code class="language-plaintext highlighter-rouge">SyntaxError</code></li> <li>只能await await able的对象， <ul> <li>在 Python 中，可等待对象可以是： <ul> <li><strong>协程</strong>：由 <code class="language-plaintext highlighter-rouge">async def</code> 函数创建。</li> <li><strong>具有 <code class="language-plaintext highlighter-rouge">__await__()</code> 方法的对象</strong>：该方法应返回一个迭代器。</li> </ul> </li> </ul> </li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">async def</code>: introduces either a <strong>native coroutine</strong> or an <strong>asynchronous generator</strong> <ul> <li>It may use <code class="language-plaintext highlighter-rouge">await</code>, <code class="language-plaintext highlighter-rouge">return</code>, or <code class="language-plaintext highlighter-rouge">yield</code> in coroutine, but all of these are optional. Declaring <code class="language-plaintext highlighter-rouge">async def noop(): pass</code> is valid <ul> <li>Using <code class="language-plaintext highlighter-rouge">await</code> and/or <code class="language-plaintext highlighter-rouge">return</code> creates a coroutine function</li> <li>use <code class="language-plaintext highlighter-rouge">yield</code> in an <code class="language-plaintext highlighter-rouge">async def</code> block. This creates an <a href="https://www.python.org/dev/peps/pep-0525/">asynchronous generator</a>， which you iterate over with <code class="language-plaintext highlighter-rouge">async for</code>.</li> </ul> </li> </ul> </li> <li>主要用法 ,大多数程序会包含小型、模块化的协程，以及一个用于将这些小协程串联在一起的包装函数。</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
# countasync.py
</span>  
<span class="kn">import</span> <span class="n">asyncio</span>
  
<span class="k">async</span> <span class="k">def</span> <span class="nf">count</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">One</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Two</span><span class="sh">"</span><span class="p">)</span>
  
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">gather</span><span class="p">(</span><span class="nf">count</span><span class="p">(),</span> <span class="nf">count</span><span class="p">(),</span> <span class="nf">count</span><span class="p">())</span>
  
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="kn">import</span> <span class="n">time</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">perf_counter</span><span class="p">()</span>
    <span class="n">asyncio</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="nf">main</span><span class="p">())</span>
    <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">s</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">__file__</span><span class="si">}</span><span class="s"> executed in </span><span class="si">{</span><span class="n">elapsed</span><span class="si">:</span><span class="mf">0.2</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">yield</code></strong>：遇到yield，函数执行会在当前代码处停止，并且会在下一次调用该函数时继续执行</p> <ul> <li> <p>pause the function and resume later</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">yield</code>的主要用法是作为generator</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># generator function
</span><span class="k">def</span> <span class="nf">odds</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
	<span class="k">for</span> <span class="n">odd</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
		<span class="k">yield</span> <span class="n">odd</span>
    
<span class="c1"># ===================
</span><span class="n">g</span> <span class="o">=</span> <span class="nf">odds</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="nf">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="c1"># return 3
</span><span class="nf">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="c1"># return 5
# Final Iteration: return StopIteration Exception
# ===================
</span><span class="n">g1</span> <span class="o">=</span> <span class="nf">odds</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
<span class="nf">list</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="c1"># return [7, 9, 11, 13]
# ===================
</span><span class="n">g2</span> <span class="o">=</span> <span class="nf">odds</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g2</span><span class="p">:</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div> </div> </li> </ul> </li> </ul> <h3 id="使用awaitasync构建生产者-消费者对列例子">使用await/async构建生产者-消费者对列例子</h3> <ul> <li>the key is to <code class="language-plaintext highlighter-rouge">await q.join()</code>, which blocks until all items in the queue have been received and processed, and then to cancel the consumer tasks, which would otherwise hang up and wait endlessly for additional queue items to appear</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
# asyncq.py
</span>
<span class="kn">import</span> <span class="n">asyncio</span>
<span class="kn">import</span> <span class="n">itertools</span> <span class="k">as</span> <span class="n">it</span>
<span class="kn">import</span> <span class="n">os</span>
<span class="kn">import</span> <span class="n">random</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">makeitem</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">.</span><span class="nf">urandom</span><span class="p">(</span><span class="n">size</span><span class="p">).</span><span class="nf">hex</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">randsleep</span><span class="p">(</span><span class="n">caller</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">caller</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">caller</span><span class="si">}</span><span class="s"> sleeping for </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s"> seconds.</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">produce</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">Queue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">it</span><span class="p">.</span><span class="nf">repeat</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>  <span class="c1"># Synchronous loop for each single producer
</span>        <span class="k">await</span> <span class="nf">randsleep</span><span class="p">(</span><span class="n">caller</span><span class="o">=</span><span class="sa">f</span><span class="sh">"</span><span class="s">Producer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">makeitem</span><span class="p">()</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">perf_counter</span><span class="p">()</span>
        <span class="k">await</span> <span class="n">q</span><span class="p">.</span><span class="nf">put</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Producer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s"> added &lt;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">&gt; to queue.</span><span class="sh">"</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">consume</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">Queue</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">await</span> <span class="nf">randsleep</span><span class="p">(</span><span class="n">caller</span><span class="o">=</span><span class="sa">f</span><span class="sh">"</span><span class="s">Consumer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="k">await</span> <span class="n">q</span><span class="p">.</span><span class="nf">get</span><span class="p">()</span>
        <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">perf_counter</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Consumer </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s"> got element &lt;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">&gt;</span><span class="sh">"</span>
              <span class="sa">f</span><span class="sh">"</span><span class="s"> in </span><span class="si">{</span><span class="n">now</span><span class="o">-</span><span class="n">t</span><span class="si">:</span><span class="mf">0.5</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds.</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">q</span><span class="p">.</span><span class="nf">task_done</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">nprod</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ncon</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="nc">Queue</span><span class="p">()</span>
    <span class="n">producers</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="p">.</span><span class="nf">create_task</span><span class="p">(</span><span class="nf">produce</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">nprod</span><span class="p">)]</span>
    <span class="n">consumers</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="p">.</span><span class="nf">create_task</span><span class="p">(</span><span class="nf">consume</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">ncon</span><span class="p">)]</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">gather</span><span class="p">(</span><span class="o">*</span><span class="n">producers</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">q</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>  <span class="c1"># Implicitly awaits consumers, too
</span>    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">consumers</span><span class="p">:</span>
        <span class="n">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="kn">import</span> <span class="n">argparse</span>
    <span class="n">random</span><span class="p">.</span><span class="nf">seed</span><span class="p">(</span><span class="mi">444</span><span class="p">)</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="nc">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">"</span><span class="s">-p</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">--nprod</span><span class="sh">"</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">"</span><span class="s">-c</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">--ncon</span><span class="sh">"</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="nf">parse_args</span><span class="p">()</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">perf_counter</span><span class="p">()</span>
    <span class="n">asyncio</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="nf">main</span><span class="p">(</span><span class="o">**</span><span class="n">ns</span><span class="p">.</span><span class="n">__dict__</span><span class="p">))</span>
    <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Program completed in </span><span class="si">{</span><span class="n">elapsed</span><span class="si">:</span><span class="mf">0.5</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <h2 id="reference">Reference</h2> <ol> <li>https://realpython.com/async-io-python/#the-asyncio-package-and-asyncawait</li> </ol>]]></content><author><name>zxy</name></author><category term="Coding"/><category term="Python"/><category term="Python"/><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">Python Cheat Sheet</title><link href="https://zxxyy.github.io/blog/2024/python-cheat-sheet/" rel="alternate" type="text/html" title="Python Cheat Sheet"/><published>2024-08-22T09:00:00+00:00</published><updated>2024-08-22T09:00:00+00:00</updated><id>https://zxxyy.github.io/blog/2024/python-cheat-sheet</id><content type="html" xml:base="https://zxxyy.github.io/blog/2024/python-cheat-sheet/"><![CDATA[<p>这篇博客主要记录一下，在实际使用Python处理数据的过程中，会涉及到的一些常用Python代码。</p> <h1 id="1-使用json读取写入文件">1. 使用json读取/写入文件</h1> <p>主要涉及4个函数</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">json.load()</code></p> <ul> <li> <p>读取一个json文件，把文件中的内容转化成为python object (load from file)</p> </li> <li> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">json</span>
<span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sh">'</span><span class="s">data.json</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">r</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_file</span><span class="p">:</span>
	<span class="n">python_object</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>
</code></pre></div> </div> </li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">json.loads()</code></p> <ul> <li> <p>解析一个字符串，把字符串转化成为python object，可以解析dict, list, int, bool, float, null等</p> <p>loads = load string</p> </li> <li> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">json</span>
<span class="n">json_string</span> <span class="o">=</span> <span class="sh">'</span><span class="s">{</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="s">: </span><span class="sh">"</span><span class="s">John</span><span class="sh">"</span><span class="s">, </span><span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="s">: 30, </span><span class="sh">"</span><span class="s">city</span><span class="sh">"</span><span class="s">: </span><span class="sh">"</span><span class="s">New York</span><span class="sh">"</span><span class="s">}</span><span class="sh">'</span>
<span class="n">python_dict</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="nf">loads</span><span class="p">(</span><span class="n">json_string</span><span class="p">)</span>
</code></pre></div> </div> </li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">json.dump()</code></p> <ul> <li> <p>序列化python object到一个文件</p> </li> <li> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">Alice</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">:</span> <span class="mi">30</span><span class="p">}</span>
<span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sh">'</span><span class="s">data.json</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">w</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="n">json</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">file</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</code></pre></div> </div> </li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">json.dumps()</code></p> <ul> <li> <p>序列化python object到json formatted string</p> </li> <li> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">json</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">Alice</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">:</span> <span class="mi">30</span><span class="p">}</span>
<span class="n">json_string</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="nf">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">json_string</span><span class="p">)</span>
</code></pre></div> </div> </li> </ul> </li> </ul> <p>使用<code class="language-plaintext highlighter-rouge">json.loads()</code>读取一个文件中的多个dict</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">//</span><span class="w"> </span><span class="err">data.json</span><span class="w">
</span><span class="p">{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Alice"</span><span class="p">,</span><span class="w"> </span><span class="nl">"age"</span><span class="p">:</span><span class="w"> </span><span class="mi">30</span><span class="p">}</span><span class="w">
</span><span class="p">{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Bob"</span><span class="p">,</span><span class="w"> </span><span class="nl">"age"</span><span class="p">:</span><span class="w"> </span><span class="mi">31</span><span class="p">}</span><span class="w">
</span><span class="p">{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Cindy"</span><span class="p">,</span><span class="w"> </span><span class="nl">"age"</span><span class="p">:</span><span class="w"> </span><span class="mi">33</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sh">'</span><span class="s">data.json</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">r</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">file</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="nf">loads</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</code></pre></div></div> <h1 id="2--print-保留小数设置格式">2. <code class="language-plaintext highlighter-rouge">print</code> 保留小数，设置格式</h1> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="o">=</span> <span class="mf">12.34567</span>
<span class="n">width</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">decimal</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="o">&lt;</span><span class="si">{</span><span class="n">width</span><span class="si">}</span><span class="p">.</span><span class="si">{</span><span class="n">decimal</span><span class="si">}</span><span class="n">f</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># Left-aligns within 10 characters, 2 decimal places
</span></code></pre></div></div> <ul> <li> <p>左对齐:<code class="language-plaintext highlighter-rouge">{:&lt;}</code></p> </li> <li>右对齐：<code class="language-plaintext highlighter-rouge">{:&gt;}</code></li> <li>居中：<code class="language-plaintext highlighter-rouge">{:^}</code></li> <li>默认使用空格当占位符，<code class="language-plaintext highlighter-rouge"> {:0&lt;}</code>表示用0充当占位符</li> </ul> <h1 id="3-正则表达式">3. 正则表达式</h1> <h2 id="元字符">元字符</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>. ^ $ * + ? { } [ ] \ | ( )
</code></pre></div></div> <p>有一些元字符不会使解析引擎在字符串中前进一个字符，他们不占用任何字符，只是表示字符串的位置信息，被称为<em>零宽度断言</em></p> <table> <thead> <tr> <th>元字符</th> <th>含义</th> <th>零宽度断言</th> <th>例子</th> <th>可匹配字符</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">.</code></td> <td>除\n外的所有字符</td> <td>否</td> <td>-</td> <td>-</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">[ ]</code></td> <td>表示匹配的字符的一个集合</td> <td>否</td> <td><code class="language-plaintext highlighter-rouge">[abc]</code></td> <td>匹配 <code class="language-plaintext highlighter-rouge">a</code>、<code class="language-plaintext highlighter-rouge">b</code>、<code class="language-plaintext highlighter-rouge">c</code> 之中的任意一个字符</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">|</code></td> <td>“or”运算符,优先级很低，一般和<code class="language-plaintext highlighter-rouge">[]</code>一起使用</td> <td>是</td> <td><code class="language-plaintext highlighter-rouge">[Crow | Servo]</code></td> <td>匹配字符串<code class="language-plaintext highlighter-rouge">Crow</code>/<code class="language-plaintext highlighter-rouge">Servo</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">\</code></td> <td>后面可以跟各种字符来表示各种特殊序列;或者用于转义元字符</td> <td>-</td> <td> </td> <td> </td> </tr> <tr> <td> </td> <td>\d 等价于字符类 <code class="language-plaintext highlighter-rouge">[0-9]</code></td> <td>否</td> <td>-</td> <td>匹配任何十进制数字</td> </tr> <tr> <td> </td> <td>\D 等价于字符类 <code class="language-plaintext highlighter-rouge">[^0-9]</code></td> <td>否</td> <td>-</td> <td>匹配任何非数字字符</td> </tr> <tr> <td> </td> <td>\s 等价于字符类 <code class="language-plaintext highlighter-rouge">[ \t\n\r\f\v]</code></td> <td>否</td> <td>-</td> <td>匹配任何空白字符</td> </tr> <tr> <td> </td> <td>\S 等价于字符类 <code class="language-plaintext highlighter-rouge">[^ \t\n\r\f\v]</code></td> <td>否</td> <td>-</td> <td>匹配任何非空白字符</td> </tr> <tr> <td> </td> <td>\w 等价于字符类 <code class="language-plaintext highlighter-rouge">[a-zA-Z0-9_]</code></td> <td>否</td> <td>-</td> <td>匹配任何字母与数字字符</td> </tr> <tr> <td> </td> <td>\W 等价于字符类 <code class="language-plaintext highlighter-rouge">[^a-zA-Z0-9_]</code></td> <td>否</td> <td>-</td> <td>匹配任何非字母与数字字符</td> </tr> <tr> <td> </td> <td>\b 仅在单词的开头或结尾处匹配,当单词包含在另一个单词中时将不会匹配</td> <td>是</td> <td><code class="language-plaintext highlighter-rouge">re.search(r'\bclass\b', 'no class at all')</code></td> <td>可以匹配到class</td> </tr> <tr> <td> </td> <td> </td> <td> </td> <td><code class="language-plaintext highlighter-rouge">re.search(r'\bclass\b', 'one subclass is')</code></td> <td>不可以匹配到class</td> </tr> </tbody> </table> <p>表示固定点标记的元字符<code class="language-plaintext highlighter-rouge">^ $</code></p> <table> <thead> <tr> <th>元字符</th> <th>含义</th> <th>零宽度断言</th> <th>例子</th> <th>可匹配字符</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">^</code></td> <td>和<code class="language-plaintext highlighter-rouge">[]</code>一起使用，表示取反，来匹配字符类中未列出的字符</td> <td>/</td> <td><code class="language-plaintext highlighter-rouge">[^0-9]</code></td> <td>不是数字的单个字符</td> </tr> <tr> <td> </td> <td>作为固定点标记，表示行/字符串的开头</td> <td>是</td> <td><code class="language-plaintext highlighter-rouge">^[a-zA-Z][a-zA-Z0-9_]{4,15}$</code></td> <td>合法账号，长度在5-16个字符之间，只能用字母数字下划线，且第一个位置必须为字母</td> </tr> <tr> <td> </td> <td> </td> <td> </td> <td><code class="language-plaintext highlighter-rouge">re.search('^From', 'From Here to Eternity')</code></td> <td>这个正则表达式可以匹配到From</td> </tr> <tr> <td> </td> <td> </td> <td> </td> <td><code class="language-plaintext highlighter-rouge">re.search('^From', 'Reciting From Memory')</code></td> <td>该字符串不以From开头，这个正则表达式匹配不到From</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">$</code></td> <td>作为固定点标记，表示行/字符串的结尾</td> <td>是</td> <td><code class="language-plaintext highlighter-rouge">re.search('}$', '{block} '</code></td> <td>匹配不到<code class="language-plaintext highlighter-rouge">}</code>（不在行/字符串的结尾）</td> </tr> <tr> <td> </td> <td> </td> <td> </td> <td><code class="language-plaintext highlighter-rouge">re.search('}$', '{block}\n')</code></td> <td>可以匹配到<code class="language-plaintext highlighter-rouge">}</code>（在行的结尾）</td> </tr> </tbody> </table> <p>和重复相关的元字符 <code class="language-plaintext highlighter-rouge">* + ? { }</code></p> <table> <thead> <tr> <th>字符</th> <th>含义</th> <th>例子</th> <th>可匹配字符</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">*</code></td> <td>表示匹配0次或多次，等价于<code class="language-plaintext highlighter-rouge">{0,}</code></td> <td><code class="language-plaintext highlighter-rouge">ca*t</code></td> <td><code class="language-plaintext highlighter-rouge">ct</code>, <code class="language-plaintext highlighter-rouge">cat</code>, <code class="language-plaintext highlighter-rouge">caat</code>…</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">+</code></td> <td>表示匹配1次或多次，等价于<code class="language-plaintext highlighter-rouge">{1,}</code></td> <td><code class="language-plaintext highlighter-rouge">ca+t</code></td> <td><code class="language-plaintext highlighter-rouge">cat</code>, <code class="language-plaintext highlighter-rouge">caat</code>…</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">?</code></td> <td>表示匹配0次或1次，等价于<code class="language-plaintext highlighter-rouge">{0,1}</code></td> <td><code class="language-plaintext highlighter-rouge">home-?brew</code></td> <td><code class="language-plaintext highlighter-rouge">homebrew</code>, <code class="language-plaintext highlighter-rouge">home-brew</code></td> </tr> <tr> <td> </td> <td>与其他重复字符一起使用，表示lazy matching，匹配尽可能少的字符</td> <td><code class="language-plaintext highlighter-rouge">re.search('&lt;.*?&gt;','&lt;python&gt;perl&gt;')</code></td> <td>匹配到<code class="language-plaintext highlighter-rouge">&lt;python&gt;</code>而不是<code class="language-plaintext highlighter-rouge">'&lt;python&gt;perl&gt;'</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">{m,n}</code></td> <td>必须至少重复 <em>m</em> 次，至多重复 <em>n</em> 次</td> <td><code class="language-plaintext highlighter-rouge">a/{1,3}b</code></td> <td><code class="language-plaintext highlighter-rouge">'a/b'</code>, <code class="language-plaintext highlighter-rouge">'a//b'</code> 和 <code class="language-plaintext highlighter-rouge">'a///b'</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">{,n} {m,}</code></td> <td>缺失 <em>m</em> 会解释为最少重复 0 次 ，缺失 <em>n</em> 则解释为最多重复无限次。</td> <td> </td> <td> </td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">{m}</code></td> <td>与前一项完全匹配 <em>m</em> 次</td> <td><code class="language-plaintext highlighter-rouge">a/{2}b</code></td> <td><code class="language-plaintext highlighter-rouge">a//b</code></td> </tr> </tbody> </table> <p>组 group</p> <table> <thead> <tr> <th>符</th> <th>含义</th> <th>例子</th> <th>可匹配字符</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">()</code></td> <td>将所包含的表达式合为一组,并且可以使用限定符例如 <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">?</code>, 或 <code class="language-plaintext highlighter-rouge">{m,n}</code> 来重复一个分组的内容</td> <td><code class="language-plaintext highlighter-rouge">(ab)*</code></td> <td>匹配 <code class="language-plaintext highlighter-rouge">ab</code> 的零次或多次重复。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">(?P&lt;name&gt;...)</code></td> <td>命名组，用于给分组命名</td> <td><code class="language-plaintext highlighter-rouge">p=re.compile('(?P&lt;first&gt;\d)-(\d)-(\d)')</code></td> <td><code class="language-plaintext highlighter-rouge">p.search('1-2-3').group('first')</code><br/>输出<code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">(?:...)</code></td> <td>表示匹配该模式，但不捕获该分组</td> <td><code class="language-plaintext highlighter-rouge">(?:\d+)</code></td> <td> </td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">\1</code></td> <td>分组的反向引用</td> <td><code class="language-plaintext highlighter-rouge">r'([ab])\1'</code></td> <td>当分组<code class="language-plaintext highlighter-rouge">([ab])</code>内的<code class="language-plaintext highlighter-rouge">a</code>或<code class="language-plaintext highlighter-rouge">b</code>匹配成功后，将开始匹配<code class="language-plaintext highlighter-rouge">\1</code>，<code class="language-plaintext highlighter-rouge">\1</code>将匹配前面分组成功的字符。因此该正则表达式将匹配<code class="language-plaintext highlighter-rouge">aa</code>或<code class="language-plaintext highlighter-rouge">bb</code>。</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">(?P=Y)</code></td> <td>Match the named group Y</td> <td> </td> <td> </td> </tr> </tbody> </table> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 带分组名称的反向引用
</span><span class="n">In</span> <span class="p">[</span><span class="mi">27</span><span class="p">]:</span>
<span class="n">s</span> <span class="o">=</span> <span class="sh">'</span><span class="s">12,56,89,123,56,98, 12</span><span class="sh">'</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">\b(?P&lt;name&gt;\d+)\b.*\b(?P=name)\b</span><span class="sh">'</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">m</span><span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">Out</span><span class="p">[</span><span class="mi">27</span><span class="p">]:</span>
<span class="sh">'</span><span class="s">12</span><span class="sh">'</span>
</code></pre></div></div> <h2 id="使用raw-string来处理反斜杠灾难">使用raw string来处理反斜杠灾难</h2> <ul> <li>正则表达式使用反斜杠字符 (<code class="language-plaintext highlighter-rouge">'\'</code>) 来表示特殊形式或允许使用特殊字符而不调用它们的特殊含义</li> <li>Python 在字符串文字中也使用(<code class="language-plaintext highlighter-rouge">\</code>)表示转义</li> </ul> <p>由于这两个规则，如果要在正则中匹配一个<code class="language-plaintext highlighter-rouge">\section</code>就需要写很多反斜杠，这会导致大量重复的反斜杠，并使得生成的字符串难以理解。</p> <table> <thead> <tr> <th style="text-align: left">字符</th> <th style="text-align: left">阶段</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">\section</code></td> <td style="text-align: left">被匹配的字符串</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">\\section</code></td> <td style="text-align: left">为 <a href="https://docs.python.org/zh-cn/3/library/re.html#re.compile"><code class="language-plaintext highlighter-rouge">re.compile()</code></a> 转义的反斜杠</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">"\\\\section"</code></td> <td style="text-align: left">为字符串字面转义的反斜杠</td> </tr> </tbody> </table> <p>因此，需要使用 Python 的原始字符串表示法来表示正则表达式；反斜杠不以任何特殊的方式处理前缀为 <code class="language-plaintext highlighter-rouge">'r'</code> 的字符串</p> <table> <thead> <tr> <th>正则</th> <th>含义</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">r"\n"</code></td> <td>一个包含 <code class="language-plaintext highlighter-rouge">'\'</code> 和 <code class="language-plaintext highlighter-rouge">'n'</code> 的双字符字符串</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">"\\n"</code></td> <td>一个包含 <code class="language-plaintext highlighter-rouge">'\'</code> 和 <code class="language-plaintext highlighter-rouge">'n'</code> 的双字符字符串</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">"\n"</code></td> <td>一个包含换行符的单字符字符</td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">"\\w+\\s+\\1"</code>和<code class="language-plaintext highlighter-rouge">r"\w+\s+\1"</code>是等价的，也就是说加了raw string后只需要考虑正则表达式内部的转义就可以了</p> <h2 id="正则表达式常用函数">正则表达式常用函数</h2> <table> <thead> <tr> <th style="text-align: left">方法 / 属性</th> <th style="text-align: left">目的</th> <th>返回值</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">match()</code></td> <td style="text-align: left">确定正则是否从字符串的开头匹配。</td> <td><code class="language-plaintext highlighter-rouge">None</code>/一个 <a href="https://docs.python.org/zh-cn/3/library/re.html#match-objects">匹配对象</a> 实例将被返回，包含匹配相关的信息：起始和终结位置、匹配的子串以及其它。</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">search()</code></td> <td style="text-align: left">扫描字符串，查找此正则匹配的任何位置，找到第一个匹配</td> <td><code class="language-plaintext highlighter-rouge">None</code>/一个 <a href="https://docs.python.org/zh-cn/3/library/re.html#match-objects">匹配对象</a> 实例将被返回，包含匹配相关的信息：起始和终结位置、匹配的子串以及其它。</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">findall()</code></td> <td style="text-align: left">找到正则匹配的所有子字符串，并将它们作为列表返回。</td> <td>findall()只取得所有匹配字符串，返回包含所有匹配字符串的列表，不关心匹配字符串在原字符串中的各项信息。</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">finditer()</code></td> <td style="text-align: left">找到正则匹配的所有子字符串，并将它们返回为一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-iterator">iterator</a>。</td> <td> </td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">split()</code></td> <td style="text-align: left">用正则表达式切分字符串，返回一个list</td> <td> </td> </tr> </tbody> </table> <p>检查匹配对象实例也有几个方法和属性</p> <table> <thead> <tr> <th style="text-align: left">方法 / 属性</th> <th style="text-align: left">目的</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">group()</code></td> <td style="text-align: left">返回正则匹配的字符串</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">start()</code></td> <td style="text-align: left">返回匹配的开始位置</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">end()</code></td> <td style="text-align: left">返回匹配的结束位置</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">span()</code></td> <td style="text-align: left">返回包含匹配 (start, end) 位置的元组</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">groups()</code></td> <td style="text-align: left">用groups()函数取出匹配的所有分组</td> </tr> </tbody> </table> <p>由于 <a href="https://docs.python.org/zh-cn/3/library/re.html#re.Pattern.match"><code class="language-plaintext highlighter-rouge">match()</code></a> 方法只检查正则是否在字符串的开头匹配，所以 <code class="language-plaintext highlighter-rouge">start()</code> 将始终为零。 但是，模式的 <a href="https://docs.python.org/zh-cn/3/library/re.html#re.Pattern.search"><code class="language-plaintext highlighter-rouge">search()</code></a> 方法会扫描字符串，因此在这种情况下匹配可能不会从零开始。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">re</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">\d{3,4}-?\d{8}</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">010-66677788,02166697788, 0451-22882828</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="nf">group</span><span class="p">())</span> <span class="c1"># [Output]: '010-66677788', search总是返回第一个成功匹配
</span><span class="nf">print</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="nf">span</span><span class="p">())</span>  <span class="c1"># [Output]: (0, 12)
</span>
<span class="n">ms</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">finditer</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">\d{3,4}-?\d{8}</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">010-66677788,02166697788, 0451-22882828</span><span class="sh">'</span><span class="p">)</span>
<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="nf">group</span><span class="p">())</span> 
<span class="c1"># Output:
# 010-66677788
# 02166697788
# 0451-22882828
</span>
<span class="n">p</span><span class="o">=</span><span class="n">re</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="sh">'</span><span class="s">(\d)-(\d)-(\d)</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="sh">'</span><span class="s">1-2-3</span><span class="sh">'</span><span class="p">).</span><span class="nf">group</span><span class="p">())</span>  <span class="c1"># [Output]:'1-2-3'
</span><span class="nf">print</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="sh">'</span><span class="s">1-2-3</span><span class="sh">'</span><span class="p">).</span><span class="nf">groups</span><span class="p">())</span> <span class="c1"># [Output]: ('1', '2', '3')
</span>
<span class="n">p</span><span class="o">=</span><span class="n">re</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="sh">'</span><span class="s">(?P&lt;first&gt;\d)-(\d)-(\d)</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="sh">'</span><span class="s">1-2-3</span><span class="sh">'</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="sh">'</span><span class="s">first</span><span class="sh">'</span><span class="p">))</span> <span class="c1"># [Output]: '1'
</span>
<span class="n">words</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">[,-]</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">010-66677788,02166697788,0451-22882828</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="c1"># [Output]: ['010', '66677788', '02166697788', '0451', '22882828']
</span>
</code></pre></div></div> <p>以下两种使用方式只是在性能上有一些区别，功能上没有区别。<code class="language-plaintext highlighter-rouge">re.compile</code>会事先编译好正则表达式，在多次循环中访问这个正则时，在性能上会更好</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">p = re.compile(&lt;regular expression&gt;)</code> + <code class="language-plaintext highlighter-rouge">p.search('&lt;target_string&gt;')</code></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">re.search('&lt;regular expression&gt;', '&lt;target_string&gt;')</code></p> </li> </ul> <h1 id="4-argparse">4. <code class="language-plaintext highlighter-rouge">argparse</code></h1> <p><code class="language-plaintext highlighter-rouge">argparse</code>中有两种类型的参数，都通过<code class="language-plaintext highlighter-rouge">add_argument()</code>这个函数添加</p> <ul> <li>positional arguments： 在命令行中的相对位置决定了这个参数的用途， <code class="language-plaintext highlighter-rouge">path</code></li> <li>optional arguments： options, flags, or switches，不是必要的，<code class="language-plaintext highlighter-rouge">long</code></li> </ul> <p>最基本的用法：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">argparse</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="nc">ArgumentParser</span><span class="p">()</span>

<span class="n">parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">"</span><span class="s">path</span><span class="sh">"</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">"</span><span class="s">-l</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">--long</span><span class="sh">"</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="sh">"</span><span class="s">store_true</span><span class="sh">"</span><span class="err">）</span>
                    
<span class="n">args</span> <span class="o">=</span> <span class="n">parse</span><span class="p">.</span><span class="nf">parse_args</span><span class="p">()</span>
</code></pre></div></div> <hr/> <p>通过添加<code class="language-plaintext highlighter-rouge">add_argument_group</code>的方式来让help的输出更加好看，对CLI的输入方式不产生影响，<strong>注意这个不是subcommand</strong>：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="nc">ArgumentParser</span><span class="p">(</span>
    <span class="n">prog</span><span class="o">=</span><span class="sh">"</span><span class="s">ls</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="sh">"</span><span class="s">List the content of a directory</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">epilog</span><span class="o">=</span><span class="sh">"</span><span class="s">Thanks for using %(prog)s! :)</span><span class="sh">"</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">general</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="nf">add_argument_group</span><span class="p">(</span><span class="sh">"</span><span class="s">general output</span><span class="sh">"</span><span class="p">)</span>
<span class="n">general</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">"</span><span class="s">path</span><span class="sh">"</span><span class="p">)</span>

<span class="n">detailed</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="nf">add_argument_group</span><span class="p">(</span><span class="sh">"</span><span class="s">detailed output</span><span class="sh">"</span><span class="p">)</span>
<span class="n">detailed</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">"</span><span class="s">-l</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">--long</span><span class="sh">"</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="sh">"</span><span class="s">store_true</span><span class="sh">"</span><span class="p">)</span>

<span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="nf">parse_args</span><span class="p">()</span>
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">argparse</code>有辅助缩写的功能，当option的名字很长的时候，可以直接用缩写，默认开启，可以使用<code class="language-plaintext highlighter-rouge">argparse.ArgumentParser(allow_abbrev=False)</code>在初始化时关闭</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">"</span><span class="s">--argument-with-a-long-name</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 以下三条指令是等价的</span>
<span class="nv">$ </span>python abbreviate.py <span class="nt">--argument-with-a-long-name</span> 42
<span class="nv">$ </span>python abbreviate.py <span class="nt">--argument</span> 42
<span class="nv">$ </span>python abbreviate.py <span class="nt">--a</span> 42
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">add_argument()</code>这个函数中对option设置不同的<code class="language-plaintext highlighter-rouge">action</code> 参数</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">argparse</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="nc">ArgumentParser</span><span class="p">()</span>
<span class="n">parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span>
    <span class="sh">"</span><span class="s">--name</span><span class="sh">"</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="sh">"</span><span class="s">store</span><span class="sh">"</span>
<span class="p">)</span>  <span class="c1"># Equivalent to parser.add_argument("--name")
</span><span class="n">parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">"</span><span class="s">--is-valid</span><span class="sh">"</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="sh">"</span><span class="s">store_true</span><span class="sh">"</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">"</span><span class="s">--is-invalid</span><span class="sh">"</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="sh">"</span><span class="s">store_false</span><span class="sh">"</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">"</span><span class="s">--item</span><span class="sh">"</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="sh">"</span><span class="s">append</span><span class="sh">"</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span>
    <span class="sh">"</span><span class="s">--version</span><span class="sh">"</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="sh">"</span><span class="s">version</span><span class="sh">"</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="sh">"</span><span class="s">%(prog)s 0.1.0</span><span class="sh">"</span>
<span class="p">)</span>
</code></pre></div></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python actions.py <span class="sb">`</span>
   <span class="nt">--name</span> Python <span class="sb">`</span>
   <span class="nt">--pi</span> <span class="sb">`</span>
   <span class="nt">--is-valid</span> <span class="sb">`</span>
   <span class="nt">--is-invalid</span> <span class="sb">`</span>
   <span class="nt">--item</span> 1 <span class="nt">--item</span> 2 <span class="nt">--item</span> 3 
<span class="nt">---------------------------------</span>
Namespace<span class="o">(</span>
    <span class="nv">name</span><span class="o">=</span><span class="s1">'Python'</span>,
    <span class="nv">is_valid</span><span class="o">=</span>True,
    <span class="nv">is_invalid</span><span class="o">=</span>False,
    <span class="nv">item</span><span class="o">=[</span><span class="s1">'1'</span>, <span class="s1">'2'</span>, <span class="s1">'3'</span><span class="o">]</span>
<span class="o">)</span>
</code></pre></div></div> <hr/> <p>一个参数有多个输入使用<code class="language-plaintext highlighter-rouge">nargs</code>，对optional 和positional arguments都适用</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">argparse</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="nc">ArgumentParser</span><span class="p">()</span>
<span class="n">parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">"</span><span class="s">files</span><span class="sh">"</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="sh">"</span><span class="s">+</span><span class="sh">"</span><span class="p">)</span>
<span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="nf">parse_args</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
</code></pre></div></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python files.py hello.txt realpython.md README.md
<span class="c"># files=['hello.txt', 'realpython.md', 'README.md']</span>
</code></pre></div></div> <hr/> <p>设置参数的指定输入</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">"</span><span class="s">--size</span><span class="sh">"</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">S</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">M</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">L</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">XL</span><span class="sh">"</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="sh">"</span><span class="s">M</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <hr/> <p>设置互斥的组，<code class="language-plaintext highlighter-rouge">-v</code>和<code class="language-plaintext highlighter-rouge">-s</code>不能在命令行中同时存在</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="nc">ArgumentParser</span><span class="p">()</span>
<span class="n">group</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="nf">add_mutually_exclusive_group</span><span class="p">(</span><span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">group</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">"</span><span class="s">-v</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">--verbose</span><span class="sh">"</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="sh">"</span><span class="s">store_true</span><span class="sh">"</span><span class="p">)</span>
<span class="n">group</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">"</span><span class="s">-s</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">--silent</span><span class="sh">"</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="sh">"</span><span class="s">store_true</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <hr/> <p>使用<code class="language-plaintext highlighter-rouge">add_subparser()</code>来添加子命令<strong>subcommand</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">global_parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="nc">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="sh">"</span><span class="s">calc</span><span class="sh">"</span><span class="p">)</span>
<span class="n">subparsers</span> <span class="o">=</span> <span class="n">global_parser</span><span class="p">.</span><span class="nf">add_subparsers</span><span class="p">(</span>
    <span class="n">title</span><span class="o">=</span><span class="sh">"</span><span class="s">subcommands</span><span class="sh">"</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="sh">"</span><span class="s">arithmetic operations</span><span class="sh">"</span>
<span class="p">)</span>

<span class="n">arg_template</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sh">"</span><span class="s">dest</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">operands</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">type</span><span class="sh">"</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">nargs</span><span class="sh">"</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">metavar</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">OPERAND</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">help</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">a numeric value</span><span class="sh">"</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">add_parser</span> <span class="o">=</span> <span class="n">subparsers</span><span class="p">.</span><span class="nf">add_parser</span><span class="p">(</span><span class="sh">"</span><span class="s">add</span><span class="sh">"</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="sh">"</span><span class="s">add two numbers a and b</span><span class="sh">"</span><span class="p">)</span>
<span class="n">add_parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="o">**</span><span class="n">arg_template</span><span class="p">)</span>
<span class="n">add_parser</span><span class="p">.</span><span class="nf">set_defaults</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">add</span><span class="p">)</span>

<span class="n">sub_parser</span> <span class="o">=</span> <span class="n">subparsers</span><span class="p">.</span><span class="nf">add_parser</span><span class="p">(</span><span class="sh">"</span><span class="s">sub</span><span class="sh">"</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="sh">"</span><span class="s">subtract two numbers a and b</span><span class="sh">"</span><span class="p">)</span>
<span class="n">sub_parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="o">**</span><span class="n">arg_template</span><span class="p">)</span>
<span class="n">sub_parser</span><span class="p">.</span><span class="nf">set_defaults</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">sub</span><span class="p">)</span>

<span class="n">mul_parser</span> <span class="o">=</span> <span class="n">subparsers</span><span class="p">.</span><span class="nf">add_parser</span><span class="p">(</span><span class="sh">"</span><span class="s">mul</span><span class="sh">"</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="sh">"</span><span class="s">multiply two numbers a and b</span><span class="sh">"</span><span class="p">)</span>
<span class="n">mul_parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="o">**</span><span class="n">arg_template</span><span class="p">)</span>
<span class="n">mul_parser</span><span class="p">.</span><span class="nf">set_defaults</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">mul</span><span class="p">)</span>

<span class="n">div_parser</span> <span class="o">=</span> <span class="n">subparsers</span><span class="p">.</span><span class="nf">add_parser</span><span class="p">(</span><span class="sh">"</span><span class="s">div</span><span class="sh">"</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="sh">"</span><span class="s">divide two numbers a and b</span><span class="sh">"</span><span class="p">)</span>
<span class="n">div_parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="o">**</span><span class="n">arg_template</span><span class="p">)</span>
<span class="n">div_parser</span><span class="p">.</span><span class="nf">set_defaults</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">div</span><span class="p">)</span>

<span class="n">args</span> <span class="o">=</span> <span class="n">global_parser</span><span class="p">.</span><span class="nf">parse_args</span><span class="p">()</span>

<span class="nf">print</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">.</span><span class="n">operands</span><span class="p">))</span>
</code></pre></div></div> <h1 id="5-unit-test-in-python">5. Unit test in Python</h1> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># project/code/my_calculations.py
</span><span class="k">class</span> <span class="nc">Calculations</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="n">self</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">b</span>

    <span class="k">def</span> <span class="nf">get_difference</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">b</span>

</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># project/test.py
</span><span class="kn">import</span> <span class="n">unittest</span>
<span class="kn">from</span> <span class="n">code.my_calculations</span> <span class="kn">import</span> <span class="n">Calculations</span>

<span class="k">class</span> <span class="nc">TestCalculations</span><span class="p">(</span><span class="n">unittest</span><span class="p">.</span><span class="n">TestCase</span><span class="p">):</span>
		<span class="c1"># 需要测试的case需要以test开头，让unittest框架识别
</span>    <span class="k">def</span> <span class="nf">test_sum</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">calculation</span> <span class="o">=</span> <span class="nc">Calculations</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="n">calculation</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(),</span> <span class="mi">10</span><span class="p">,</span> <span class="sh">'</span><span class="s">The sum is wrong.</span><span class="sh">'</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">'</span><span class="s">__main__</span><span class="sh">'</span><span class="p">:</span>
    <span class="n">unittest</span><span class="p">.</span><span class="nf">main</span><span class="p">()</span>
</code></pre></div></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-m</span> unittest
python <span class="nt">-m</span> unittest <span class="nt">-v</span> project.test <span class="c"># 指定单元测试的文件</span>
</code></pre></div></div> <h1 id="reference">Reference</h1> <ol> <li><a href="https://notebook.community/liupengyuan/python_tutorial/chapter3/python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">python正则表达式快速基础教程</a></li> <li> <p><a href="https://pythonhowto.readthedocs.io/zh-cn/latest/regular.html">正则表达式</a></p> </li> <li><a href="https://docs.python.org/zh-cn/3/howto/regex.html">正则表达式指南</a></li> <li><a href="https://realpython.com/command-line-interfaces-python-argparse/#creating-command-line-interfaces-with-pythons-argparse">real python argparse</a></li> <li><a href="https://realpython.com/python-unittest/">real python unitest</a></li> <li><a href="https://www.dataquest.io/blog/unit-tests-python/">A Beginner’s Guide to Unit Tests in Python (2023)</a></li> </ol>]]></content><author><name>zxy</name></author><category term="Coding"/><category term="Python"/><category term="Python"/><summary type="html"><![CDATA[这篇博客主要记录一下，在实际使用Python处理数据的过程中，会涉及到的一些常用Python代码。]]></summary></entry><entry><title type="html">MIT6.824 Lab2A Raft Leader Election</title><link href="https://zxxyy.github.io/blog/2023/raft-leader/" rel="alternate" type="text/html" title="MIT6.824 Lab2A Raft Leader Election"/><published>2023-12-31T09:00:00+00:00</published><updated>2023-12-31T09:00:00+00:00</updated><id>https://zxxyy.github.io/blog/2023/raft-leader</id><content type="html" xml:base="https://zxxyy.github.io/blog/2023/raft-leader/"><![CDATA[<blockquote> <p>阅读本篇blog前需要理解raft leader election的基本概念，阅读Raft论文Section1、2、5，弄明白Figure2，以及尝试实现Lab2A</p> <p>Lab Description: <a href="https://pdos.csail.mit.edu/6.824/labs/lab-raft.html">https://pdos.csail.mit.edu/6.824/labs/lab-raft.html</a></p> <p>Raft Lecture: <a href="https://youtu.be/R2-9bsKmEbo">https://youtu.be/R2-9bsKmEbo</a></p> <p>Raft Lecture Notes: <a href="https://pdos.csail.mit.edu/6.824/notes/l-raft.txt">https://pdos.csail.mit.edu/6.824/notes/l-raft.txt</a></p> <p>Raft paper: <a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf</a></p> <p>Raft official website: <a href="https://raft.github.io/">https://raft.github.io/</a></p> <p>Raft可视化动画: <a href="https://thesecretlivesofdata.com/raft/">https://thesecretlivesofdata.com/raft/</a></p> </blockquote> <p>这篇博客中记录我实现Raft Leader Election这个实验的过程，以及实现过程中遇到的问题。这可能比仅仅看最后的源码实现，可以带给你更多的帮助。这篇博客对应的源码也已开源<a href="https://github.com/ZXXYy/mit6.824-2023">https://github.com/ZXXYy/mit6.824-2023</a></p> <h2 id="prelimary-setup">Prelimary Setup</h2> <p>由于Raft算法的随机性，各个peer的超时时间、投票给谁都不确定。运行一次 <code class="language-plaintext highlighter-rouge">go test -run 2A</code>通过所有测试，并不代表2A的实现没有bug。因此，我们需要多次测试程序，要保证代码的正确性。MIT6.824的助教用Python写了一个批量测试的脚本，我们可以直接拿来用，链接在 <a href="https://gist.github.com/JJGO/0d73540ef7cc2f066cb535156b7cbdab">Utility for running MIT 6.824 lab test in parallel and saving failed logs</a>。</p> <p>把该脚本直接拷贝下来，存在 <code class="language-plaintext highlighter-rouge">raft</code> 目录下，执行 <code class="language-plaintext highlighter-rouge">python3 dstest.py 2A -n 10</code> 就可以批量测试代码。 <code class="language-plaintext highlighter-rouge">-n 10</code> 表示测试多少次，默认是 10。如下是批量测试运行中的一个截图。</p> <p><img src="/assets/img/in-post/2023-12-31-raft-leader/test.png" alt="截屏2024-01-03 10.00.26"/></p> <p>测试100次后，成功的截图如下：</p> <p><img src="/assets/img/in-post/2023-12-31-raft-leader/result.png" alt="截屏2024-01-03 10.08.40"/></p> <p>关于高效的进行日志打印相关内容可以参考这篇blog <a href="https://blog.josejg.com/debugging-pretty/">Debugging by Pretty Printing</a>。</p> <h2 id="raft-leader-election-keypoint">Raft Leader Election Keypoint</h2> <ul> <li><strong>核心思想</strong>：在任意一个时间点，至多只有一个leader，由这个leader来接收和分发用户的请求，来避免split-brain的问题。所有的信息都从leader流向follower。</li> <li><strong>目标</strong>: 基于majority rule，选举出一个leader。</li> </ul> <h2 id="my-implementation">My Implementation</h2> <p>在通读Lab2A的实验说明之后，可以理解本次实验需要改动的代码只有一个文件<code class="language-plaintext highlighter-rouge">src/raft/raft.go</code>，在<code class="language-plaintext highlighter-rouge">raft.go</code>内主要需要实现四个内容(raft数据结构，ticker()，requestVote RPC，Append Entries RPC)：</p> <ul> <li>raft数据结构及<code class="language-plaintext highlighter-rouge">make()</code>初始化raft数据结构 <ul> <li>raft数据结构按照paper Figure2的内容设计，除此之外还需要添加3个额外的信息 <ul> <li>heartbeat：用来记录心跳，记录leader上一次发送心跳包（即AppendEntries）的时间</li> <li>electionTimer: 用来记录每一个raft服务心跳超时的时常，在make中以random的方式初始化，在这里我设置成150-350ms不等</li> <li>isLeader: 用来记录当前raft服务器是否是leader</li> </ul> </li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">ticker()</code></p> <ul> <li>主要任务是查看心跳包是否超时，如果超时了，把follower转变成为candidate，向其他rafts发送requestVote RPC</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">requestVote</code> RPC</p> <ul> <li> <p>requestVote的数据结构按照Figure2中的Request RPC设计，没有额外的要求。</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">RequestVoteArgs</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="c">// Your data here (2A, 2B).</span>
	<span class="n">Term</span>         <span class="kt">int</span> <span class="c">// the candidate's term</span>
	<span class="n">CandidateId</span>  <span class="kt">int</span> <span class="c">// the candidate requesting the vote</span>
	<span class="n">LastLogIndex</span> <span class="kt">int</span> <span class="c">// the index of the candidate's last log entry</span>
	<span class="n">LastLogTerm</span>  <span class="kt">int</span> <span class="c">// the term of the candidate's last log entry</span>
<span class="p">}</span>
    
<span class="c">// example RequestVote RPC reply structure.</span>
<span class="c">// field names must start with capital letters!</span>
<span class="k">type</span> <span class="n">RequestVoteReply</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="c">// Your data here (2A).</span>
	<span class="n">Term</span>        <span class="kt">int</span>  <span class="c">// the current term of the peer</span>
	<span class="n">VoteGranted</span> <span class="kt">bool</span> <span class="c">// true if the peer granted the vote</span>
<span class="p">}</span>
    
</code></pre></div> </div> </li> <li>RequestVote RPC主要做的事情是: <ul> <li>发送requestVote请求，根据返回的请求内容，判断投票数是否大于整体raft数量的1/2，进而判断是否要转变成为leader</li> </ul> </li> <li>RequestVote RPC handler主要做的事情是：判断要不要投票给发起该请求的candidate <ul> <li>如果当前args.Term &lt; rf.currentTerm，说明candidate的信息未完全同步，不能当leader，投反对票</li> <li>如果当前args.Term &gt; rf.currentTerm，表明raft在这个term当中未投过票; 如果args.Term == rf.currentTerm，根据rf.votedFor的值来判断是否投过票</li> <li>如果raft未投过票，并且candidate的最后一个log term大于等于当前raft的log term，log index也大于等于当前raft的log index，grant vote</li> </ul> </li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">AppendEntries</code> RPC</p> <ul> <li> <p>AppendEntries的数据结构在2A中只需用到Term</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">AppendEntriesArgs</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Term</span>     <span class="kt">int</span> <span class="c">// the leader's term</span>
	<span class="n">LeaderId</span> <span class="kt">int</span> <span class="c">// the leader's id</span>
<span class="p">}</span>
    
<span class="k">type</span> <span class="n">AppendEntriesReply</span> <span class="k">struct</span><span class="p">{}</span>
</code></pre></div> </div> </li> <li>AppendEntries RPC主要做的事情是：2A中如果当前raft是leader，就发送心跳包</li> <li>AppendEntries RPC handler主要做的事情是：更新heartbeat信息，如果当前term小于请求raft的term，将isLeader置为false</li> </ul> </li> </ul> <h2 id="problems-i-met">Problems I met</h2> <ol> <li>在网络发生问题时，有信息被阻塞，导致在限定时间内没有leader被选举出来，最后发现是在发送RPC call时应该新开一个现场，即用<code class="language-plaintext highlighter-rouge">go rf.sendRequestVote(i, &amp;args, &amp;reply)</code>， <code class="language-plaintext highlighter-rouge">go rf.sendAppendEntries(i)</code>。 不然，当网络发生异常时，程序会直接被阻塞住。</li> </ol> <h2 id="一些好的blogs">一些好的blogs</h2> <p><a href="https://medium.com/codex/journey-to-mit-6-824-lab-2a-raft-leader-election-974087a55740">journey-to-mit-6-824-lab-2a-raft-leader-election</a></p> <p><a href="https://blog.rayzhang.top/2022/11/09/mit-6.824-lab2-raft/index.html#%E6%89%B9%E9%87%8F%E6%B5%8B%E8%AF%95">mit-6.824-lab2-raft</a></p>]]></content><author><name>zxy</name></author><category term="Coding"/><category term="Courses"/><category term="MIT6.824"/><category term="MIT6.824"/><summary type="html"><![CDATA[阅读本篇blog前需要理解raft leader election的基本概念，阅读Raft论文Section1、2、5，弄明白Figure2，以及尝试实现Lab2A Lab Description: https://pdos.csail.mit.edu/6.824/labs/lab-raft.html Raft Lecture: https://youtu.be/R2-9bsKmEbo Raft Lecture Notes: https://pdos.csail.mit.edu/6.824/notes/l-raft.txt Raft paper: https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf Raft official website: https://raft.github.io/ Raft可视化动画: https://thesecretlivesofdata.com/raft/]]></summary></entry><entry><title type="html">Linux中的top command</title><link href="https://zxxyy.github.io/blog/2023/top/" rel="alternate" type="text/html" title="Linux中的top command"/><published>2023-12-13T09:00:00+00:00</published><updated>2023-12-13T09:00:00+00:00</updated><id>https://zxxyy.github.io/blog/2023/top</id><content type="html" xml:base="https://zxxyy.github.io/blog/2023/top/"><![CDATA[<p>最近在跑一些可以并行的代码，开几个进程，消耗多少CPU占用率，这些决定变得很重要。而<code class="language-plaintext highlighter-rouge">top</code>指令就是用来查看CPU占用率的。于是，想记录一下怎么看top的输出，以及top中常用的subcommand。</p> <h1 id="top输出分析">Top输出分析</h1> <p>在终端输入<code class="language-plaintext highlighter-rouge">top</code>就会输出如下内容，由顶部的五行和一个process table组成：</p> <p><img src="/assets/img/in-post/2023-12-14-top/overview.png" alt="overview"/></p> <p>我们一行行来看：</p> <p><img src="/assets/img/in-post/2023-12-14-top/detail.png" alt="detail"/></p> <p>其中，Nice Value和priority的区别如下：</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">Nice value</code> 是用户空间的，而 <code class="language-plaintext highlighter-rouge">priority</code>（PR）是进程实际优先级，由 Linux 内核使用。在 Linux 系统中，优先级范围是 0 到 139，其中 0 到 99 用于实时进程，100 到 139 用于用户进程。Nice value 的范围是 -20 到 +19，其中 -20 表示最高，0 表示默认，+19 表示最低。<code class="language-plaintext highlighter-rouge">Nice value</code> 和 <code class="language-plaintext highlighter-rouge">priority</code> 之间的关系如下：</p> \[PR = 20 + NI\] </li> </ul> <h1 id="top常用指令">Top常用指令</h1> <ol> <li> <p>输入top后，按下数字键 1 可以查看系统上每个 CPU 核心的图形表示，再按一次可以切换回原来的界面</p> <p><img src="/assets/img/in-post/2023-12-14-top/core.png" alt="core"/></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">top -u &lt;username&gt;</code> 展示指定用户的cpu占用率</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">top -i</code>输出当前idle的进程</p> </li> <li> <p>按下 <code class="language-plaintext highlighter-rouge">Shift+L</code> 可以按名称查找进程。这会在粗体表头行的正上方创建一个提示。输入查找的进程名称，然后按 Enter 或 Return 键，以查看新排序的进程列表中突出显示的该进程的实例。</p> <p><img src="/assets/img/in-post/2023-12-14-top/locate.png" alt="locate"/></p> </li> </ol> <h1 id="reference">Reference</h1> <p>[1] https://www.redhat.com/sysadmin/interpret-top-output</p> <p>[2] https://askubuntu.com/questions/656771/process-niceness-vs-priority</p> <p>[3] https://opensource.com/article/22/3/linux-top-command</p>]]></content><author><name>zxy</name></author><category term="Coding"/><category term="Linux"/><category term="Commands"/><category term="Linux"/><category term="Tools"/><summary type="html"><![CDATA[最近在跑一些可以并行的代码，开几个进程，消耗多少CPU占用率，这些决定变得很重要。而top指令就是用来查看CPU占用率的。于是，想记录一下怎么看top的输出，以及top中常用的subcommand。]]></summary></entry><entry><title type="html">ARM交叉编译工具链与编译选项</title><link href="https://zxxyy.github.io/blog/2023/cross-compile/" rel="alternate" type="text/html" title="ARM交叉编译工具链与编译选项"/><published>2023-11-29T09:00:00+00:00</published><updated>2023-11-29T09:00:00+00:00</updated><id>https://zxxyy.github.io/blog/2023/cross-compile</id><content type="html" xml:base="https://zxxyy.github.io/blog/2023/cross-compile/"><![CDATA[<h2 id="toolchain是什么">Toolchain是什么</h2> <p>Toolchain是一组将源代码转换为可执行程序的工具的集合。主要包括：</p> <ol> <li> <p>Binutils（Binary Utilities）: 一组用于创建和管理二进制程序、目标文件、库、性能分析数据以及汇编源代码的编程工具集。主要包括：</p> <ul> <li>assembler汇编器<code class="language-plaintext highlighter-rouge">as</code>：把汇编语言转化为机器码</li> <li>linker链接器<code class="language-plaintext highlighter-rouge">ld</code>: 将多个obj文件、库文件和其他必要的资源组合在一起，生成最终的可执行程序</li> <li><code class="language-plaintext highlighter-rouge">objcopy</code>: 用于复制和转换obj文件的工具。可以用来在不同的可执行文件格式之间进行转换，或提取目标文件的特定部分。</li> <li><code class="language-plaintext highlighter-rouge">objdump</code>: 反汇编obj文件，提供obj文件的汇编代码、头部信息和节（section）的详细信息</li> <li><code class="language-plaintext highlighter-rouge">strip</code>, <code class="language-plaintext highlighter-rouge">readelf</code>, <code class="language-plaintext highlighter-rouge">ar</code>, <code class="language-plaintext highlighter-rouge">size</code>等</li> </ul> </li> <li> <p>Compiler编译器: 将高级编程语言（如C、C++）翻译成机器代码的工具。它接收源代码文件并生成相应的obj文件，比如GCC。</p> </li> <li> <p>Run-time Libraries运行时库：各种支持运行时期间的功能的库文件，例如标准C库、数学库等。这些库在程序执行期间被动态链接到程序中。<strong>在编译用户空间的程序时会链接运行时库，但是在编译内核时不需要运行时库。</strong></p> <p>对于Unix系统来说，Run-time library就是基于POSIX规范的标准化应用程序接口（API），由C语言定义。它是应用程序与操作系统内核之间的主要接口。有很多不同的C library可以根据不同的场景进行选择：</p> <ul> <li> <p>libc: Linux下的ANSI C的函数库，包括<code class="language-plaintext highlighter-rouge">&lt;stdlib.h&gt;</code>，<code class="language-plaintext highlighter-rouge">&lt;stdio.h&gt;</code>，<code class="language-plaintext highlighter-rouge">&lt;string.h&gt;</code>，<code class="language-plaintext highlighter-rouge">&lt;time.h&gt;</code>等</p> </li> <li>glibc: GNU C library</li> <li>musl libc：轻量化的C library，适用于RAM和存储有限的情况</li> <li>newlib: 一个面向嵌入式系统的C library</li> <li>uClibc-ng: micro controller C library</li> </ul> </li> <li> <p>Linux headers</p> </li> <li> <p>Debugger: 提供了诸如设置断点、查看变量内容、跟踪程序执行流程等功能，例如gdb。</p> </li> </ol> <h2 id="abi是什么">ABI是什么</h2> <p>在构建Toolchain时，我们需要规定二进制文件生成的规范，比如数据类型的大小、布局和对齐，函数调用时参数应该怎么传递，函数返回值如何返回，如何进行系统调用等。这些规范都由<strong>ABI（Application binary interface）</strong>来规定。ABI 的设计目标是简化系统的软件开发和移植过程，使得不同的编译器、库和工具链能够生成和使用符合同一规范的二进制文件。</p> <p>在一个系统中，kernel和所有的应用程序都应该遵循同一个ABI规范。</p> <p>由于嵌入式系统的发展，ARM架构在2000年末提出了<strong>EABI(Extended Application Binary Interface)</strong>的规范，用于定义在嵌入式系统中生成和运行二进制程序的接口。ARM之前定义的规范，也就被称为<strong>OABI (Old Application Binary Interface)</strong>。</p> <p>EABI的规范又根据浮点数的传递方式分为两类</p> <ul> <li>eabi: 通过通用整数寄存器传递</li> <li>eabihf (hf for Hard-Float)：通过硬件的浮点寄存器传递，速度快但是不兼容没有FPU（ floating point unit）的CPU</li> </ul> <h2 id="toolchain编译流程">Toolchain编译流程</h2> <p>Toolchain将源代码转换为可执行程序的流程如下图所示：</p> <p><img src="/assets/img/in-post/2023-11-29-cross-compile/compile.png" alt="compilation"/></p> <p>在嵌入式系统的构建中，我们也需要通过上述的流程，使用toolchain来构建嵌入式Linux系统的三个部分：the bootloader, the kernel, and the root filesystem。通常，用于 Linux 的工具链是基于 GNU 项目的组件构建的。</p> <h2 id="case-studyarm交叉编译链">Case Study：ARM交叉编译链</h2> <p>根据不同的架构、开发商、目标设备上运行的操作系统、abi等可以有各种不同的toolchain。这一节我们先了解工具链的命名规则，再看看常见的ARM交叉编译链。</p> <h3 id="工具链的命名规则">工具链的命名规则</h3> <p>一般来说，Toolchain的命名规则为： <code class="language-plaintext highlighter-rouge">[arch]-[vendor]-[kernel]-[system]-</code></p> <p><img src="/assets/img/in-post/2023-11-29-cross-compile/toolchain.png" alt="toolchain"/></p> <ul> <li>arch: 表示目标芯片架构，比如 32 位的 Arm 架构对应的 arch 为 arm，64 位的 Arm 架构对应的 arch 为 aarch64。 <ul> <li>如果 CPU 支持两种字节序模式，可以通过添加 “<strong>el</strong>” 表示小端（little-endian），或者添加 “<strong>eb</strong>” 表示大端（big-endian）来区分。例如，小端MIPS 架构可以用 “mipsel” 表示，而大端ARM 架构可以用 “armeb” 表示。</li> </ul> </li> <li>vendor：工具链提供商，大部分工具链名字里面都没有包含这部分。常见的工具链提供商有buildroot, poky, unknown, none.</li> <li>kernel ：编译出来的可执行文件(目标文件)针对的操作系统，比如 Linux, uclinux, bare（无OS）。</li> <li>system: 交叉编译链所选择的库函数和目标映像规范，如gnu, gnueabi, gnueabihf, musleabi, or musleabihf等。 <ul> <li>gnu = gnu C library + oabi</li> <li>gnueabi = gnu C library+ eabi</li> <li>musleabi = musl C library + eabi</li> </ul> </li> </ul> <h3 id="常见的arm交叉编译链">常见的ARM交叉编译链</h3> <p>arm交叉编译器下载：</p> <ul> <li><a href="https://releases.linaro.org/components/toolchain/binaries/">linaro社区</a>：老版本，版本范围 4.9 ~ 7.5</li> <li><a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads">arm官网</a> ： 新版本，版本范围 8.2 ~10.3</li> </ul> <p>下面我们来看几个常见的例子：</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">arm-none-linux-gnueabi-gcc</code> 表示基于arm架构的，适用于任何CPU型号，linux系统下的，可编译出符合GNU规范以及EABI接口要求的，c语言的编译器。</p> </li> <li><code class="language-plaintext highlighter-rouge">arm-none-eabi-gcc </code> 表示基于arm架构的，适用于任何CPU型号（也可理解成不指定具体的工具链供应商），不带操作系统的裸机系统（包括 ARM Linux 的 boot、kernel，不适用于编译 Linux 应用 Application），可编译出符合嵌入式平台ABI接口要求的，c语言的编译器。 <ul> <li>一般适用用于 Arm Cortex-M/Cortex-R 平台，它使用的是 专用于嵌入式系统的newlib C 库。</li> <li>编译裸机的toolchain可以不用说明用的Runtime C library（也就是没有gnu这一项），因为在编译的时候不会用到C library</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">arm-linux-gnueabi-gcc</code> 和 <code class="language-plaintext highlighter-rouge">aarch64-linux-gnu-gcc</code> 适用于 Arm Cortex-A 系列芯片，前者针对 32 位芯片，后者针对 64 位芯片，它使用的是 glibc 库。也可以用来编译 u-boot、linux kernel 以及应用程序。</li> <li><code class="language-plaintext highlighter-rouge">arm-linux-gnueabihf-gcc</code>: 表示基于arm架构的，适用于任何CPU型号，linux系统下的，可编译出符合GNU规范以及EABIHF接口要求的，c语言的编译器。 硬件的浮点寄存器传递传递浮点数。</li> </ul> <blockquote> <p><code class="language-plaintext highlighter-rouge">arm-linux-gnueabi-gcc</code>和<code class="language-plaintext highlighter-rouge">arm-linux-gnueabihf-gcc</code>的区别：</p> <ul> <li>其实这两个交叉编译器只不过是gcc的选项-mfloat-abi的默认值不同 <ul> <li>gnueabi表示用以下gcc选项<code class="language-plaintext highlighter-rouge">-mfloat-abi=soft</code> or <code class="language-plaintext highlighter-rouge">-mfloat-abi=softfp</code>编译</li> <li>gnueabihf表示用<code class="language-plaintext highlighter-rouge"> -mfloat-abi=hard </code>编译，表示编译器和库可以使用硬件的浮点运算指令。</li> </ul> </li> <li>既然只是编译选项不同，为什么要有两个不同的工具链呢？因为工具链包括了binutils，已经编译的libraries（libc）等，这两个不同的工具链表示工具链中的库支不支持使用浮点寄存器传参。</li> </ul> </blockquote> <p>早期的arm处理器，因为在CPU内部没有专门的浮点运算硬件单元，所以对应的编译器遇到浮点运算的程序代码时，不会将它们翻译成使用FPU（floating point unit）计算的机器指令，而是将浮点运算翻译成在CPU的算术逻辑单元（ALU）上软件模拟的指令代码。后面的处理器开始逐渐集成FPU，对应的编译器选项<code class="language-plaintext highlighter-rouge">-mfloat-abi</code>也就有了三个：</p> <ul> <li>soft版：不使用FPU进行浮点运算，适合早期无FPU的ARM处理器</li> <li>softfp版： armel架构（对应的编译器为 arm-linux-gnueabi-gcc ）使用FPU进行浮点运算，但使用普通寄存器传参，编译器使用该版本，用来兼容没有FPU的处理器</li> <li>hard版：armhf架构（对应的编译器 arm-linux-gnueabihf-gcc ）使用FPU进行浮点运算，使用浮点寄存器传参，性能最高，但中断负荷最大，适用于现在高性能的集成FPU的处理器</li> </ul> <p>其中后两者都要求arm里有fpu浮点运算单元，soft与后两者是兼容的，但softfp和hard两种模式互不兼容</p> <p>不同的芯片厂商，发布自己不同处理器、不同平台的SDK时，使用的编译器版本可能不一样，一般我们建议，使用原厂的编译环境就可以了。而对于内核的学习，为了保持兼容性，建议使用softfp就可以了。</p> <h2 id="reference">Reference</h2> <ol> <li> <p>Book: Mastering Embedded Linux Programming</p> </li> <li><a href="https://stackoverflow.com/questions/26692065/difference-between-arm-eabi-arm-gnueabi-and-gnueabi-hf-compilers">Stackoverflow: Difference between arm-eabi arm-gnueabi and gnueabi-hf compilers</a></li> <li><a href="https://www.cnblogs.com/xiaotlili/p/3306100.html">交叉编译器 arm-linux-gnueabi 和 arm-linux-gnueabihf 的区别</a></li> <li><a href="https://en.wikipedia.org/wiki/GNU_Binutils">Wiki: GNU Binutils</a></li> <li><a href="https://education.sakshi.com/en/cseit/study-material/linux-system-programming/cross-compiling-tool-chains-44792">Cross Compiling ToolChains</a></li> <li><a href="https://blog.csdn.net/LEON1741/article/details/81537529">交叉编译器的命名规则及详细解释</a></li> <li><a href="https://stackoverflow.com/questions/3321468/whats-the-difference-between-hard-and-soft-floating-point-numbers">Stackoverflow: What’s the difference between hard and soft floating point numbers?</a></li> </ol>]]></content><author><name>zxy</name></author><category term="Coding"/><category term="System"/><category term="ARM"/><category term="ARM"/><category term="Compiler"/><summary type="html"><![CDATA[Toolchain是什么]]></summary></entry><entry><title type="html">MIT6.824 Lab1 Map Reduce</title><link href="https://zxxyy.github.io/blog/2023/map-reduce/" rel="alternate" type="text/html" title="MIT6.824 Lab1 Map Reduce"/><published>2023-11-24T09:00:00+00:00</published><updated>2023-11-24T09:00:00+00:00</updated><id>https://zxxyy.github.io/blog/2023/map-reduce</id><content type="html" xml:base="https://zxxyy.github.io/blog/2023/map-reduce/"><![CDATA[<blockquote> <p>阅读本篇blog前需要理解map reduce的基本概念，以及尝试实现Lab1</p> <p>Lab Description: <a href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">https://pdos.csail.mit.edu/6.824/labs/lab-mr.html</a></p> <p>Map reduce Lecture: <a href="https://youtu.be/WtZ7pcRSkOA">https://youtu.be/WtZ7pcRSkOA</a></p> <p>Map reduce Lecture Notes: <a href="https://pdos.csail.mit.edu/6.824/notes/l01.txt">https://pdos.csail.mit.edu/6.824/notes/l01.txt</a></p> <p>Mao reduce paper: <a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf</a></p> </blockquote> <p>这篇博客中记录我实现map reduce这个实验的过程，以及实现过程中遇到的问题。这可能比仅仅看最后的源码实现，可以带给你更多的帮助。这篇博客对应的源码也已开源<a href="https://github.com/ZXXYy/mit6.824-2023">https://github.com/ZXXYy/mit6.824-2023</a></p> <h2 id="mapreduce-key-point">MapReduce Key point</h2> <ul> <li> <p><strong>核心思想</strong>：将大规模的数据处理任务分解成可以并行处理的小任务，并通过Map 阶段和 Reduce 阶段来实现数据处理。</p> </li> <li><strong>目标</strong>: easy for non-expert to write distributed applications，即程序员只需定义映射和归约函数，通常是相当简单的顺序代码。分布式的所有方面由MapReduce 框架管理并隐藏。</li> <li><strong>Approach</strong>： <ul> <li>map + reduce function(stateless)–一般由用户提供</li> <li>map reduce framework/library deals with distribution–框架实现</li> </ul> </li> <li> <p><strong>Abstract view:</strong></p> <p>​A bunch of files: f1, f2, f3…</p> <p>​keys, values = map(f1), word count = map</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input1 -&gt; Map -&gt; a,1 b,1
Input2 -&gt; Map -&gt;     b,1
Input3 -&gt; Map -&gt; a,1     c,1
                  |   |   |
                  |   |   -&gt; Reduce -&gt; c,1
                  |   -----&gt; Reduce -&gt; b,2
                  ---------&gt; Reduce -&gt; a,2
1) input is (already) split into M files
2) MR calls Map() for each input file, produces list of k,v pairs
  "intermediate" data
  each Map() call is a "task"
3) when Maps are done,
  MR gathers all intermediate v's for each k,
  and passes each key + values to a Reduce call
4) final output is set of &lt;k,v&gt; pairs from Reduce()s
</code></pre></div> </div> </li> </ul> <p><strong>Expensive costs</strong>: The reduce function needs to contact every mapper to extract the output and fetch intermediate results through network.</p> <ul> <li> <p>Can map and reduce function run twice? yes, map and reduce both are stateless—functional &amp; deterministic</p> </li> <li> <p>Coordinate cannot fail, coordinate has states.</p> </li> <li> <p>What about slow workers? backup/replicate tasks, go for the first finishing task.</p> </li> </ul> <h2 id="my-implementation">My Implementation</h2> <p>在通读Lab1的实验说明之后，可以理解需要在以下文件中新增代码：</p> <ul> <li><code class="language-plaintext highlighter-rouge">src/mr/coordinator.go</code>：增加状态维护，任务分配逻辑</li> <li><code class="language-plaintext highlighter-rouge">src/mr/worker.go</code>： 新增map/reduce任务的执行逻辑，即如何调用用户提供的mapf和reducef函数</li> <li><code class="language-plaintext highlighter-rouge">src/mr/rpc.go</code>: 新增RPC call参数和返回值的结构体</li> </ul> <p>整个MapReduce的流程如下：</p> <ol> <li>worker通过RPC向coordinator请求一个任务</li> <li>coordinator将当前未完成的任务分配给这个worker</li> <li>worker根据coordinator的RPC返回值执行相应的Map/Reduce任务</li> <li>worker完成任务后，通过RPC通知coordinator相应任务已经完成</li> </ol> <p>其中，需要注意的细节有：</p> <ol> <li>reduce任务必须在所有map任务完成后才可以开始</li> <li>coordinator需要处理crashed worker的情况，在某个worker很长一段时间没响应后，应该把该worker上的任务分配给其他worker</li> </ol> <p>有了上述理解之后，我们就可以开始设计相应的数据结构了。</p> <h3 id="data-structure">Data Structure</h3> <p>Coordinator中需要维护任务的对应状态，设计如下：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 通过Status来表示对应处理文件的处理状态</span>
<span class="k">type</span> <span class="n">Status</span> <span class="kt">int32</span>

<span class="k">const</span> <span class="p">(</span>
	<span class="n">Ready</span>   <span class="n">Status</span> <span class="o">=</span> <span class="m">0</span> <span class="c">// 等待worker处理</span>
	<span class="n">Process</span> <span class="n">Status</span> <span class="o">=</span> <span class="m">1</span> <span class="c">// 有worker正在处理</span>
	<span class="n">Done</span>    <span class="n">Status</span> <span class="o">=</span> <span class="m">2</span> <span class="c">// 已完成处理</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">FileStatus</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">status</span>    <span class="n">Status</span>
	<span class="n">timestamp</span> <span class="kt">int64</span>	<span class="c">// 通过timestamp来处理crashed worker的情况，如果worker处理的时间过长，coordinator再次分配该任务给新worker</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Coordinator</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">files</span>             <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">FileStatus</span> <span class="c">// 表示需要处理的原始文件，由map函数分析，如files['pg-grimm.txt']={Ready, 0}</span>
	<span class="n">filesIndex</span>        <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>        <span class="c">// 给每一个原始文件一个index，便于索引</span>
	<span class="n">intermediateFiles</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">FileStatus</span> <span class="c">// 表示map后的中间文件，由reduce函数分析</span>
	<span class="n">intermediateIndex</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>        <span class="c">// 给每一个中间文件一个index，便于索引</span>
	<span class="n">nReduce</span>           <span class="kt">int</span>
	<span class="n">fileMutex</span>         <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>            <span class="c">// 整个结构体的锁，防止多个进程对该结构访问造成的数据竞争</span>
<span class="p">}</span>
</code></pre></div></div> <p>worker需要向coordinator请求任务以及通知coordinator任务已经完成，所以设计了两个RPC call（<code class="language-plaintext highlighter-rouge">AssignTask</code>和<code class="language-plaintext highlighter-rouge">FinishTask</code>）。</p> <p>这两个RPC call对应的数据结构如下：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">TaskArgs</span> <span class="k">struct</span><span class="p">{}</span>
<span class="k">type</span> <span class="n">TaskReply</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">NReduce</span>       <span class="kt">int</span>     <span class="c">// 告诉worker总共有几个reduce task</span>
	<span class="n">Nmap</span>          <span class="kt">int</span>     <span class="c">// 告诉worker总共有几个map task</span>
	<span class="n">MapTaskNum</span>    <span class="kt">int</span>     <span class="c">// 告诉worker当前处理的是第几个map task</span>
	<span class="n">ReduceTaskNum</span> <span class="kt">int</span>     <span class="c">// 告诉worker当前处理的是第几个reduce task</span>
	<span class="n">TaskType</span>      <span class="kt">string</span>  <span class="c">// 告诉worker需要处理的task类型是map还是reduce</span>
	<span class="n">TaskFile</span>      <span class="kt">string</span>  <span class="c">// 告诉worker需要处理的文件是哪个</span>
<span class="p">}</span>
<span class="c">// ⚠️!：MapTaskNum这个参数只会在map task中使用</span>
<span class="c">// ⚠️!：ReduceTaskNum这个参数只会在reduce task中使用</span>
</code></pre></div></div> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">FinishArgs</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">TaskType</span> <span class="kt">string</span>     <span class="c">// 告诉coordinator当前完成的任务类型</span>
	<span class="n">TaskFile</span> <span class="kt">string</span>     <span class="c">// 告诉coordinator当前完成的任务对应的文件</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">FinishReply</span> <span class="k">struct</span><span class="p">{}</span>
</code></pre></div></div> <h3 id="rpc-call">RPC Call</h3> <p>具体流程如下，源码实现详见GitHub</p> <p>Coordinator</p> <ul> <li> <p>AssignTask</p> <ol> <li>处理crashed worker情况，判断当前是否有正在处理的task过长时间没响应 <ul> <li>若有讲该task状态设置为Ready，便于后续分配给新worker</li> </ul> </li> <li>处理原始文件，如果当前有原始文件未处理，将该map任务分配给worker</li> <li>判断所有原始文件已经处理完成，否则告诉worker等待</li> <li>若所有原始文件处理完成，处理map生成的中间文件，将给reduce任务分配给worker</li> </ol> </li> <li> <p>FinishTask</p> <ul> <li>更新对应任务的文件状态</li> </ul> </li> </ul> <p>Worker对应的代码如下：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Worker</span><span class="p">(</span><span class="n">mapf</span> <span class="k">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="n">KeyValue</span><span class="p">,</span> <span class="n">reducef</span> <span class="k">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="no">true</span><span class="p">{</span>
    <span class="c">// RPC call</span>
    <span class="n">task</span><span class="p">,</span> <span class="n">taskfile</span><span class="p">,</span> <span class="n">nreduce</span><span class="p">,</span> <span class="n">nmap</span><span class="p">,</span> <span class="n">mapTaskNum</span><span class="p">,</span> <span class="n">reduceTaskNum</span> <span class="o">:=</span> <span class="n">AvailableForTask</span><span class="p">()</span>
    <span class="c">// 判断task类型</span>
    <span class="k">if</span> <span class="n">task</span> <span class="o">==</span> <span class="s">"map"</span> <span class="p">{</span>
      <span class="n">do_map</span><span class="p">(</span><span class="n">taskfile</span><span class="p">,</span> <span class="n">nreduce</span><span class="p">,</span> <span class="n">mapTaskNum</span><span class="p">,</span> <span class="n">mapf</span><span class="p">)</span>
      <span class="c">// task完成后通知coordinator</span>
      <span class="n">CallFinishTask</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">taskfile</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">task</span> <span class="o">==</span> <span class="s">"reduce"</span> <span class="p">{</span>
      <span class="n">do_reduce</span><span class="p">(</span><span class="n">taskfile</span><span class="p">,</span> <span class="n">nmap</span><span class="p">,</span> <span class="n">reduceTaskNum</span><span class="p">,</span> <span class="n">reducef</span><span class="p">)</span>
      <span class="n">CallFinishTask</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">strconv</span><span class="o">.</span><span class="n">Itoa</span><span class="p">(</span><span class="n">reduceTaskNum</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">do_map</code>, <code class="language-plaintext highlighter-rouge">do_reduce</code>可以参考<code class="language-plaintext highlighter-rouge">mrsequential.go</code>完成, coordinator中的<code class="language-plaintext highlighter-rouge">Done</code>逻辑较为简单，此处省略。</p> <h2 id="problems-i-met">Problems I met</h2> <ol> <li> <p>在RPC Call的Reply中worker收到的值均为0，原因是go中的RPC structure内的field首字母必须要大写。</p> <ul> <li>在 Go 中，首字母大写的标识符是导出的，可以被其他包访问。</li> <li>如果字段的首字母是小写的，则它们只能在定义它们的包内访问，相当于是私有的。</li> </ul> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>
<span class="k">import</span> <span class="s">"fmt"</span>
<span class="c">// MyStruct 是一个示例结构体</span>
<span class="k">type</span> <span class="n">MyStruct</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PublicField</span>  <span class="kt">int</span>    <span class="c">// 导出字段</span>
    <span class="n">privateField</span> <span class="kt">string</span> <span class="c">// 非导出字段（私有）</span>
<span class="p">}</span>
   
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 创建结构体实例</span>
    <span class="n">myInstance</span> <span class="o">:=</span> <span class="n">MyStruct</span><span class="p">{</span>
        <span class="n">PublicField</span><span class="o">:</span>  <span class="m">42</span><span class="p">,</span>
        <span class="n">privateField</span><span class="o">:</span> <span class="s">"secret"</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c">// 访问导出字段</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"PublicField:"</span><span class="p">,</span> <span class="n">myInstance</span><span class="o">.</span><span class="n">PublicField</span><span class="p">)</span>
    <span class="c">// 访问非导出字段会导致编译错误</span>
    <span class="c">// fmt.Println("privateField:", myInstance.privateField)</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li> <p>在运行map parallelism/reduce parallelism测试时，报错<code class="language-plaintext highlighter-rouge">fatal error: concurrent map writes</code></p> <p>由于多个worker的RPC call可能同时访问coordinator中的各种map结构，所以coordinator中需要锁来解决concurrency的问题。</p> </li> <li> <p>在运行early exit测试时，程序不通过测试</p> <p>reduce任务必须在所有map任务完成后才可以开始，即在reduce任务前必须判断原始文件的file Status均为Done，若有文件状态是Process，worker进程也需进入等待状态。</p> </li> </ol>]]></content><author><name>zxy</name></author><category term="Coding"/><category term="Courses"/><category term="MIT6.824"/><category term="MIT6.824"/><summary type="html"><![CDATA[阅读本篇blog前需要理解map reduce的基本概念，以及尝试实现Lab1 Lab Description: https://pdos.csail.mit.edu/6.824/labs/lab-mr.html Map reduce Lecture: https://youtu.be/WtZ7pcRSkOA Map reduce Lecture Notes: https://pdos.csail.mit.edu/6.824/notes/l01.txt Mao reduce paper: https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf]]></summary></entry><entry><title type="html">使用gcov/lcov测试用例的代码覆盖率</title><link href="https://zxxyy.github.io/blog/2023/gcov/" rel="alternate" type="text/html" title="使用gcov/lcov测试用例的代码覆盖率"/><published>2023-11-22T09:00:00+00:00</published><updated>2023-11-22T09:00:00+00:00</updated><id>https://zxxyy.github.io/blog/2023/gcov</id><content type="html" xml:base="https://zxxyy.github.io/blog/2023/gcov/"><![CDATA[<p>gcov（GNU Coverage）是GCC的一部分，用于代码覆盖率分析。它用于确定源代码中的哪些部分已经执行，并生成相应的覆盖率报告。</p> <h2 id="基本流程">基本流程</h2> <ol> <li><strong>编译时插桩：</strong>在使用 <code class="language-plaintext highlighter-rouge">gcov</code> 时，需要在编译代码时启用覆盖率分析选项。通过在编译命令中包含 <code class="language-plaintext highlighter-rouge">-fprofile-arcs</code> 和 <code class="language-plaintext highlighter-rouge">-ftest-coverage</code> 选项，编译器会在生成的可执行文件中插入代码，以便在执行时记录代码的执行路径。 <ul> <li><code class="language-plaintext highlighter-rouge">-fprofile-arcs</code> ：表示启用代码覆盖率分析，<strong>它告诉编译器在生成的可执行文件中插入代码</strong>来记录程序的执行路径。这种记录通常以一种称为 “arc” 的形式存在，代表程序中的分支或决策点。每当程序执行经过一个分支时，<code class="language-plaintext highlighter-rouge">-fprofile-arcs</code> 会记录该信息，从而构建执行路径的统计数据。</li> <li><code class="language-plaintext highlighter-rouge">-ftest-coverage</code>：用于生成代码覆盖率信息，<strong>它告诉编译器生成额外的代码</strong>，以在程序执行时收集覆盖率信息，并将此信息存储在相应的数据文件中（通常是以 <code class="language-plaintext highlighter-rouge">.gcda</code> 后缀结尾的文件）。这些数据文件包含有关程序中每个源代码文件的执行路径的信息。</li> </ul> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-fprofile-arcs</span> <span class="nt">-ftest-coverage</span> <span class="nt">-o</span> your_program your_program.c
</code></pre></div> </div> <p>使用这两个编译选项编译代码后，这将生成一个可执行文件 <code class="language-plaintext highlighter-rouge">your_program</code>，以及与每个源文件关联的 <code class="language-plaintext highlighter-rouge">.gcno</code> 文件（<code class="language-plaintext highlighter-rouge">.gcno</code> 以及<code class="language-plaintext highlighter-rouge">.gcda</code>这两种文件会在相关文件类型中会有详细介绍）。</p> </li> <li> <p><strong>运行可执行文件：</strong> 运行生成的可执行文件，执行测试用例或运行应用程序。<code class="language-plaintext highlighter-rouge">gcov</code> 会在执行期间收集覆盖率信息。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./your_program
</code></pre></div> </div> <p>在运行成功后，会生成相应的 <code class="language-plaintext highlighter-rouge">your_program.gcda</code> 文件，其中包含有关代码执行路径的数据。</p> </li> <li> <p><strong>生成报告：</strong> 运行 <code class="language-plaintext highlighter-rouge">gcov</code> 工具，它会分析 <code class="language-plaintext highlighter-rouge">gcda</code> 文件（由执行时生成的数据文件）和源代码，生成一个详细的覆盖率报告。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcov your_program.gcda
</code></pre></div> </div> <p>通过运行 <code class="language-plaintext highlighter-rouge">gcov</code> 工具可以从 <code class="language-plaintext highlighter-rouge">.gcda</code> 文件生成 <code class="language-plaintext highlighter-rouge">.gcov</code> 文件（此处为<code class="language-plaintext highlighter-rouge">your_program.c.gcov</code>），提供关于每个源代码文件的详细覆盖率信息。</p> <p>通过使用<code class="language-plaintext highlighter-rouge">gcov gcda 2.gcda xx.gcda</code>指定多个gcda文件也可以一次性生成多个源文件的覆盖率报告。</p> </li> </ol> <p>最简单的gcov指令<code class="language-plaintext highlighter-rouge">gcov fib.gcda </code>会生成如下报告：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>File 'fib.c'
Lines executed:82.35% of 17
Creating 'fib.c.gcov'
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">gcov</code>常用的参数有：</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">-b</code> 输出分支语句频率信息到输出文件, 以及概要信息到标准输出, 但不显示无条件分支</p> <p><code class="language-plaintext highlighter-rouge">gcov -b fib.gcda </code>生成如下报告：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>File 'fib.c'
Lines executed:82.35% of 17
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls
Creating 'fib.c.gcov'
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">-l</code> 在报告.gcov中显示代码文件中的每一行。</li> <li><code class="language-plaintext highlighter-rouge">-c</code> 以数字而不是百分比显示分支频率</li> <li><code class="language-plaintext highlighter-rouge">-f</code>在报告中显示函数级别的覆盖率信息。</li> <li><code class="language-plaintext highlighter-rouge">-p</code>在 .gocv 文件名中加入完整的路径信息, 此时路径中的 ‘/’ 用 ‘#’ 表示, ‘..’ 用 ‘^’ 表示</li> </ul> <h2 id="相关文件类型">相关文件类型</h2> <p><img src="/assets/img/in-post/2023-11-22-gcov/overview.jpeg" alt="img"/></p> <h3 id="1-gcno">1. <code class="language-plaintext highlighter-rouge">.gcno</code></h3> <p><code class="language-plaintext highlighter-rouge">.gcno</code>（Coverage Notes）文件是由GCC生成的一个文件类型，用于代码覆盖率分析。这个文件包含有关源代码中各个语句、分支和函数的信息，以便在程序执行时收集覆盖率数据。</p> <ol> <li><strong>基本块信息：</strong> 源代码中的基本块（basic block）的信息。</li> <li><strong>分支信息：</strong> 程序中的分支（例如 <code class="language-plaintext highlighter-rouge">if</code> 语句）的信息，以便跟踪哪些分支已经执行。</li> <li><strong>函数信息：</strong> 程序中的函数的信息，以便了解哪些函数已经执行。</li> </ol> <p>这些信息是通过在源代码中插入额外的代码而生成的，这些代码负责跟踪程序的执行路径。<code class="language-plaintext highlighter-rouge">.gcno</code> 文件则包含有关如何生成 <code class="language-plaintext highlighter-rouge">.gcda</code> 文件所需的信息。</p> <h3 id="2-gcda">2. <code class="language-plaintext highlighter-rouge">.gcda</code></h3> <p><code class="language-plaintext highlighter-rouge">.gcda</code>（Coverage Data）文件是由GCC生成的一种文件类型，用于存储程序的代码覆盖率数据。这个文件包含有关源代码中的哪些部分已经执行的信息，以便进行详细的代码覆盖率分析。</p> <p>具体来说，<code class="language-plaintext highlighter-rouge">.gcda</code> 文件记录了程序在执行时经过的代码路径，包括已执行的基本块（basic block）、分支和函数。这些数据是通过在程序中插入代码来收集的，插入的代码负责跟踪执行的路径，然后将信息写入 <code class="language-plaintext highlighter-rouge">.gcda</code> 文件。</p> <h3 id="3-gcov">3. <code class="language-plaintext highlighter-rouge">gcov</code></h3> <p><code class="language-plaintext highlighter-rouge">.gcov</code> 文件是由 <code class="language-plaintext highlighter-rouge">gcov</code> 工具生成的代码覆盖率报告文件。它提供了<strong>关于源代码文件</strong>中哪些行已经执行的详细信息，包括每行代码的执行次数、覆盖率百分比等。</p> <p><code class="language-plaintext highlighter-rouge">.gcov</code> 文件是一个文本文件，其内容类似于以下示例：</p> <pre><code class="language-txt">        -:    0:Source:your_program.c
        -:    0:Graph:your_program.gcno
        -:    0:Data:your_program.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* Hello, World! program */
        -:    2:#include &lt;stdio.h&gt;
        -:    3:
        1:    4:int main() {
    		1:    5:    // Displaying "Hello, World!" on the console
        1:    6:    printf("Hello, World!\n");
        1:    7:
        -:    8:    // Return 0 to indicate successful execution
        1:    9:    return 0;
        -:   10:}
</code></pre> <p>在这个示例中，每一行表示源代码文件中的一行代码，以及相关的执行信息。例如，第 4 行表示 <code class="language-plaintext highlighter-rouge">main</code> 函数执行了 1 次，第 6 行表示 <code class="language-plaintext highlighter-rouge">printf("Hello, World!\n");</code> 语句也执行了 1 次。</p> <p>总的来说，gcno是编译后就生成的，gcda是运行程序后生成的，gcov是运行gcov gcda后生成的。</p> <h2 id="lcov">lcov</h2> <p>由于<code class="language-plaintext highlighter-rouge">.gcov</code>的报告可读性差，通过<code class="language-plaintext highlighter-rouge">lcov</code>和<code class="language-plaintext highlighter-rouge">gcovr</code>等前端可视化工具可以将<code class="language-plaintext highlighter-rouge">.gcda</code>中的数据整理出来，便于阅读。</p> <p><code class="language-plaintext highlighter-rouge">lcov</code> 是一个用于生成代码覆盖率报告的工具，解析 <code class="language-plaintext highlighter-rouge">gcov</code> 生成的 <code class="language-plaintext highlighter-rouge">.gcda</code> 和 <code class="language-plaintext highlighter-rouge">.gcno</code> 文件来收集覆盖率数据。</p> <p><code class="language-plaintext highlighter-rouge">lcov</code>主要的优点有：</p> <ul> <li><strong>支持过滤和排除</strong>： <code class="language-plaintext highlighter-rouge">lcov</code> 可以进行过滤和排除，以便在报告中仅显示感兴趣的文件或排除某些文件。</li> <li><strong>生成总体覆盖率报告：</strong><code class="language-plaintext highlighter-rouge">lcov</code> 能够生成总体的覆盖率报告，展示整个项目的代码覆盖率情况。</li> <li><strong>生成 HTML 报告：</strong> 除了文本报告，<code class="language-plaintext highlighter-rouge">lcov</code> 还能够生成更可视化的 HTML 格式的报告。这些报告可以通过网页浏览器查看，提供了更直观的代码覆盖率信息。</li> </ul> <p>lcov生成覆盖率常用命令如下（转https://blog.csdn.net/qq_32534441/article/details/90645316）：</p> <ol> <li><strong>生成全量覆盖率</strong></li> </ol> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lcov <span class="nt">-b</span> &lt;测试代码路径&gt; <span class="nt">-d</span> &lt;gcda目录位置&gt; <span class="nt">-c</span> <span class="nt">-o</span> result.info <span class="nt">--rc</span> <span class="nv">lcov_branch_coverage</span><span class="o">=</span>1
</code></pre></div></div> <ul> <li> <p><code class="language-plaintext highlighter-rouge">-b</code> b for base directory（Use DIR as base directory for relative paths）为指定原代码路径，即生成gcno数据时编译的代码路径(make时的路径)</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">-d</code> d for directory，为gcda所在目录，可以将所有的gcda放置在一个目录中</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">-c</code>代表生成覆盖率数据（Capture coverage data），后面不用给其他参数</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">-o</code>指定生成的文件名，这里指定文件为当前目录下的result.info</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">–rc lcov_branch_coverage=1</code>表示包含分支数据， rc for Override configuration file setting</p> <blockquote> <p>在当前最新版（1.14）的lcov中，指定lcov_branch_coverage=1可能没有效果，解决办法如下：</p> <ol> <li>复制一份<code class="language-plaintext highlighter-rouge">/etc/lcovrc</code>到<code class="language-plaintext highlighter-rouge">~/.lcovrc </code></li> <li>将<code class="language-plaintext highlighter-rouge">~/.lcovrc</code>中的lcov_branch_coverage设置为1，即<code class="language-plaintext highlighter-rouge">lcov_branch_coverage = 1</code></li> </ol> </blockquote> </li> </ul> <ol> <li> <p><strong>Merg多份覆盖率数据</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lcov -a phase1.info -a phase2.info -o out.info
</code></pre></div> </div> </li> </ol> <p>​ 其中phase1.info以及phase2.info为独立了的两份覆盖率数据，他们整合为一份out.info</p> <ol> <li> <p><strong>展示result.info</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lcov --list result.info
</code></pre></div> </div> </li> </ol> <p>​ 展示result.info中的code coverage信息</p> <ol> <li> <p><strong>在.info文件中正向提取需要统计覆盖率的文件，生成报告</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 比如希望把source相关的路径提取出来
lcov --extract Debug/coverage.info 'source/' -o Debug/finalresult.info
</code></pre></div> </div> </li> <li> <p><strong>在.info文件中反向删除不需要统计覆盖率的文件，生成报告</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 比如希望去除UnitTest 和/usr/相关文件
lcov --remove Debug/coverage.info 'UnitTest/' '/usr/*' -o Debug/finalresult.info
</code></pre></div> </div> </li> </ol> <blockquote> <p>其他工具：</p> <ol> <li><a href="https://github.com/gcovr/gcovr">gcovr</a> 是一个 Python 工具，用于生成更易读的、基于文本的代码覆盖率报告。它是对 <code class="language-plaintext highlighter-rouge">gcov</code> 和 <code class="language-plaintext highlighter-rouge">lcov</code> 工具的一种封装，目的是提供一种更简单、更直观的方式来查看和分析代码的测试覆盖率情况。</li> <li><a href="https://github.com/vanhauser-thc/afl-cov,">afl-cov</a> 基于gcov, 用于AFL Fuzzing Code Coverage</li> </ol> </blockquote> <h2 id="实战使用gcovlcov测试qemu-code-coverage">实战：使用gcov+lcov测试QEMU Code Coverage</h2> <ol> <li> <p>下载QEMU源码</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 不同版本的qemu都可以从这个网址上下载https://download.qemu.org/</span>
wget https://download.qemu.org/qemu-8.0.5.tar.xz
<span class="nb">tar </span>xvJf qemu-8.0.5.tar.xz
<span class="nb">cd </span>qemu-8.0.5
</code></pre></div> </div> </li> <li> <p>根据自己的需要配置configure文件生成make</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>build
<span class="nb">cd </span>build
../configure <span class="nt">--help</span> <span class="c"># 查看可以配置的编译选项</span>
./configure <span class="nt">--disable-kvm</span> <span class="nt">--disable-xen</span> <span class="nt">--enable-gcov</span> <span class="nt">--extra-cflags</span><span class="o">=</span><span class="s2">"-fprofile-arcs -ftest-coverage"</span> <span class="nt">--target-list</span><span class="o">=</span><span class="s2">"aarch64-softmmu arm-softmmu arm-linux-user aarch64-linux-user"</span>
</code></pre></div> </div> <ul> <li>根据需要可以disable一些特性，比如此处通过<code class="language-plaintext highlighter-rouge">--disable-kvm --disable-xen</code> 关闭硬件虚拟化</li> <li><code class="language-plaintext highlighter-rouge">--enable-gcov --extra-cflags="-fprofile-arcs -ftest-coverage"</code> 启动code coverage插桩，在一些QEMU版本中，可能还没有<code class="language-plaintext highlighter-rouge">--enable-gcov</code>，所以需要加上<code class="language-plaintext highlighter-rouge">--extra-cflags="-fprofile-arcs -ftest-coverage"</code></li> <li><code class="language-plaintext highlighter-rouge">--target-list="aarch64-softmmu arm-softmmu arm-linux-user aarch64-linux-user"</code>选择要编译生成的target</li> </ul> </li> <li> <p>编译qemu</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make
</code></pre></div> </div> </li> <li> <p>编译成功后在build文件夹下可以看到很多.gcno文件</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="nt">-R</span> | <span class="nb">grep</span> .gcno 
</code></pre></div> </div> </li> <li> <p>启动运行qemu程序, 此处以qemu-arm为例</p> <ul> <li>创建需要在qemu上模拟运行的程序</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// hello.c</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">return</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Hello, I am an ARM32 binary!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div> </div> <ul> <li>使用交叉编译链编译hello.c <code class="language-plaintext highlighter-rouge">arm-linux-gnueabi-gcc -static -o hello32 hello.c</code></li> <li>运行qemu-arm</li> </ul> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># under build directory</span>
./arm-linux-user/qemu-arm <span class="nt">-L</span> /usr/arm-linux-gnueabi ./hello32
</code></pre></div> </div> </li> <li> <p>成功运行后，可以看到build文件夹会生成.gcda文件</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="nt">-R</span> | <span class="nb">grep</span> .gcno
</code></pre></div> </div> </li> <li> <p>通过<code class="language-plaintext highlighter-rouge">lcov</code>生成code coverage信息</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lcov <span class="nt">--rc</span> <span class="nv">lcov_branch_coverage</span><span class="o">=</span>1 <span class="nt">-c</span> <span class="nt">-d</span> <span class="nb">.</span> <span class="nt">-o</span> coverage.info
<span class="c"># 通过-d可以选中指定目录下的.gcda文件，生成报告</span>
lcov <span class="nt">--rc</span> <span class="nv">lcov_branch_coverage</span><span class="o">=</span>1 <span class="nt">-c</span> <span class="nt">-d</span> ./libqemu-arm-linux-user.fa.p <span class="nt">-o</span> coverage2.info
</code></pre></div> </div> </li> <li> <p>查看code coverage</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lcov <span class="nt">--list</span> coverage.info
</code></pre></div> </div> </li> </ol> <blockquote> <p>如果多次运行qemu程序，相应的code coverage信息会叠加起来存在.gcda文件中，只需要查看最终的.gcda就可以获得所有测试样例综合起来的coverage信息</p> </blockquote> <h2 id="reference">Reference</h2> <ol> <li><a href="https://blog.csdn.net/qq_32534441/article/details/90645316">gcov代码覆盖率测试-原理和实践总结</a></li> <li><a href="https://danielsieger.com/blog/2022/03/06/code-coverage-for-cpp.html">Code Coverage Testing for C++</a></li> <li><a href="https://medium.com/@xianpeng.shen/use-gcov-and-lcov-to-perform-code-coverage-testing-for-c-c-projects-c85708b91c78">Code coverage testing of C/C++ projects using Gcov and LCOV</a></li> <li> <p><a href="https://www.qemu.org/docs/master/devel/testing.html#gcc-gcov-support">QEMU GCC gcov support</a></p> </li> <li><a href="https://github.com/shenxianpeng/gcov-example">gcov-example</a></li> <li><a href="https://gcc.gnu.org/onlinedocs/gcc/Gcov.html">gcov—a Test Coverage Program</a></li> <li>https://stackoverflow.com/questions/32249416/gcovr-generate-a-0-coverage-report-if-cpp-gcno-and-gcda-files-are-not-present</li> <li>https://stackoverflow.com/questions/12360167/generating-branch-coverage-data-for-lcov</li> <li><a href="https://azeria-labs.com/arm-on-x86-qemu-user/">RUNNING ARM BINARIES ON X86 WITH QEMU-USER</a></li> </ol>]]></content><author><name>zxy</name></author><category term="Coding"/><category term="System"/><category term="Tools"/><category term="Tools"/><summary type="html"><![CDATA[gcov（GNU Coverage）是GCC的一部分，用于代码覆盖率分析。它用于确定源代码中的哪些部分已经执行，并生成相应的覆盖率报告。]]></summary></entry><entry><title type="html">rust编译器初探：Rust编译器是如何工作的</title><link href="https://zxxyy.github.io/blog/2023/rustc/" rel="alternate" type="text/html" title="rust编译器初探：Rust编译器是如何工作的"/><published>2023-10-09T09:00:00+00:00</published><updated>2023-10-09T09:00:00+00:00</updated><id>https://zxxyy.github.io/blog/2023/rustc</id><content type="html" xml:base="https://zxxyy.github.io/blog/2023/rustc/"><![CDATA[<blockquote> <p>阅读本篇博客需要了解编译原理相关知识，比如词法分析、语法分析、语义分析、代码生成等。</p> <p>阅读本篇博客需要有一定的Rust语言基础，比如知道lifetime, ownership, borrow等概念。</p> </blockquote> <p>这篇博客主要学习记录Rust程序编译的整个流程。一般的编译过程分为词法分析、语法分析、语义分析、代码生成这些步骤，Rust的编译器也逃脱不了这个框架。Rust编译器特殊的地方在于：（1）由于Rust引入了新的类型系统（ownership, borrow等），Rust编译器还需要做一些额外的检查（比如，borrow checking）。（2）为了实现demand-driven compilation，Rust编译器定义了一个特殊的查询系统(query system)。</p> <h1 id="overview">Overview</h1> <p>下图展示了编译Rust程序的主要步骤：</p> <p><img src="/assets/img/in-post/2023-10-09-rustc/overview.png" alt="截屏2023-10-09 20.17.19"/></p> <h4 id="1-词法分析-lexing">1. 词法分析 (Lexing)</h4> <p>Lexer把源码转化为一个个tokens。</p> <h4 id="2-语法分析-parsing">2. 语法分析 (Parsing)</h4> <h5 id="ast">AST</h5> <p>Parser把tokens转化为抽象语法树（AST）。</p> <h5 id="hir">HIR</h5> <p>接着，AST会被转化成为HIR（High-level intermediate representation）。HIR是一种对编译器更加友好的 AST 表示，在AST到HIR的转化过程中会进行：</p> <ol> <li> <p>macro expansion</p> </li> <li> <p>desugar语法糖，比如<code class="language-plaintext highlighter-rouge">for n in num</code>类似的语法糖会被展开成<code class="language-plaintext highlighter-rouge">match</code>和<code class="language-plaintext highlighter-rouge">loop</code></p> <p>来看一个例子，对以下代码：</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="k">let</span> <span class="n">numbers</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
	<span class="k">for</span> <span class="n">n</span> <span class="k">in</span> <span class="n">numbers</span> <span class="p">{</span>
		<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div> </div> <p>我们关注<code class="language-plaintext highlighter-rouge">for n in numbers</code>这个循环，这个语法糖会被desugar为：</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="k">match</span> <span class="nn">IntoIterator</span><span class="p">::</span><span class="nf">into_iter</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">mut</span> <span class="n">iter</span> <span class="k">=&gt;</span> <span class="k">loop</span> <span class="p">{</span>
     <span class="k">let</span> <span class="n">next</span><span class="p">;</span>
     <span class="k">match</span> <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
       <span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">val</span><span class="p">,</span>
       <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
     <span class="p">};</span>
     <span class="p">(</span><span class="o">...</span><span class="p">)</span>
 	<span class="p">},</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li> <p>resolve imports</p> </li> </ol> <p>unsafe的代码块信息在HIR中还没有被删除。</p> <p>HIR的数据结构表示如下：</p> <ul> <li> <p>Node: 一个node对应一个代码片段，每一个node都有一个HirId，并且属于一个definition</p> </li> <li>Definition: an item in the crate we are compiling. These are primarily top level items within the crate. This is identified by a DefId, and a definition is owned by a crate.</li> <li>Crate: It stores the contents of the crate we are compiling and contains a number of maps and other things that help organize the content for easier access throughout the compilation process. This crate is identified with a CrateNum.</li> </ul> <p><img src="/assets/img/in-post/2023-10-09-rustc/hir.png" alt="截屏2023-10-10 11.28.49"/></p> <h5 id="mir">MIR</h5> <p>最后，HIR会被转化为MIR（Mid-level intermediate representation）。MIR说白了就是一张控制流图（control flow graph），basic block（bb）组成MIR的基本单元，每一个basic block中包含顺序执行的statement，basic block中最后一个statement被称为terminator。</p> <p>statement主要由三种形式组成: Assignment, StorageLive和StorageDead</p> <ul> <li>Assignment: 把RValue赋值给LValue，赋值方式有mov, &amp;, *等</li> <li>StorageLive: where a variable’s storage comes into existence，用来表示变量生命周期的开始</li> <li>StorageDead: where a variable’s storage goes out of existence，用来表示变量生命周期的结束</li> </ul> <p>MIR中的syntax如下：</p> <p><img src="/assets/img/in-post/2023-10-09-rustc/mir_syntax.png" alt="截屏2023-10-10 11.58.42"/></p> <p>下面这段代码对应的MIR如下：</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">condition</span> <span class="p">{</span>
 	<span class="n">do_one_thing</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="n">do_something_else</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="/assets/img/in-post/2023-10-09-rustc/bb.png" alt="截屏2023-10-10 11.43.46"/></p> <p>在这个HIR–MIR lowering过程中，一个more desugared HIR–THIR（Typed HIR）也会被构建出来。Rust 代码是单态化的（monomorphized），换句话说，就是编译器需要用具体类型替换generic中的类型参数，生成每一个具体类型所对应的代码。为此，我们需要收集一个列表，列出要生成代码的具体类型。这被称为单形态化收集，发生在 MIR 层。</p> <h4 id="3-语义分析-semantic-analysis">3. 语义分析 (Semantic Analysis)</h4> <p>这个阶段，编译器会做很多轮的检查。</p> <p>AST中会进行syntactic sanity checking，比如检查用户编写的类型是否是预期类型。</p> <p>HIR用于类型推断(type inference), trait solving(将 impl 与每个对特征的引用配对的过程)以及类型检查(type checking)。类型检查是将用户编写的类型信息（在编译器中表示为<code class="language-plaintext highlighter-rouge">hir::Ty</code>）转化为编译器内部的类型表示(<code class="language-plaintext highlighter-rouge">rustc_middle::ty::Ty&lt;'tcx&gt;</code>)。</p> <p>THIR用于patterning和exhaustiveness checking。</p> <p>MIR用于borrow checking的分析和其他基于数据流的检查(dataflow-based checks)，比如检查未初始化的值。</p> <p>borrow checking会检查的内容有：</p> <ul> <li>Tracking initializations and moves</li> <li>Lifetime inference <ul> <li>If you make a reference to a value, the lifetime of that reference cannot outlive the scope of the value</li> </ul> </li> <li>drop check</li> </ul> <h4 id="4-optimiaztion--code-generation">4. Optimiaztion &amp; Code generation</h4> <p>MIR是high-level and generic的中间代码表示，还没有被单态化，所以在MIR上做优化会比LLVM IR上高效很多。</p> <p>代码生成阶段是将源代码的更高级别表示转换为可执行二进制文件的阶段。在代码生成的过程中，编译器首先将MIR转化成为LLVM IR，这个阶段中MIR真正被monomorphized。LLVM IR会接着被喂给LLVM，LLVM会对LLVM IR再做一些优化，并生成机器码。</p> <h1 id="queries">Queries</h1> <p>Rust编译器通过使用query system来完成增量编译（incremental compilation），即如果用户对其程序进行更改并重新编译，编译器希望尽量减少不必要的工作量，以生成新的二进制文件。</p> <p>在Rust编译器（rustc）中，编译的主要步骤都被组织成一组互相调用的queries。比如，有一个query用于获取某个东西的类型，另一个用于获取某个函数的MIR。这些查询可以相互调用，并且都通过查询系统进行跟踪。查询的结果被缓存到磁盘上，以便我们可以确定哪些查询的结果与上次编译不同，只重新执行那些查询。这就是增量编译的工作原理。</p> <h1 id="reference">Reference</h1> <ol> <li> <p><a href="https://rustc-dev-guide.rust-lang.org/overview.html">Overview of te compiler</a></p> </li> <li> <p><a href="https://www.infoq.com/presentations/rust-borrow-checker/">The Rust Borrow Checker – a Deep Dive</a></p> </li> <li> <p>Preliminaries Section of “SafeDrop: Detecting Memory Deallocation Bugs of Rust Programs via Static Data-Flow Analysis”</p> </li> </ol>]]></content><author><name>zxy</name></author><category term="Coding"/><category term="Rust"/><category term="Compiler"/><category term="Rust"/><summary type="html"><![CDATA[阅读本篇博客需要了解编译原理相关知识，比如词法分析、语法分析、语义分析、代码生成等。 阅读本篇博客需要有一定的Rust语言基础，比如知道lifetime, ownership, borrow等概念。]]></summary></entry><entry><title type="html">Linux KVM x86内存虚拟化EPT源代码分析</title><link href="https://zxxyy.github.io/blog/2023/kvm-mem-source/" rel="alternate" type="text/html" title="Linux KVM x86内存虚拟化EPT源代码分析"/><published>2023-09-12T09:00:00+00:00</published><updated>2023-09-12T09:00:00+00:00</updated><id>https://zxxyy.github.io/blog/2023/kvm-mem-source</id><content type="html" xml:base="https://zxxyy.github.io/blog/2023/kvm-mem-source/"><![CDATA[<blockquote> <p>阅读本篇博客前请先阅读</p> <ol> <li><a href="https://zxxyy.github.io/posts/SPT-EPT/">x86内存虚拟化–影子页表(Shadow Page Table)和拓展页表(EPT)</a></li> <li><a href="https://zxxyy.github.io/posts/kvm-cpu-virt/">Linux KVM x86 CPU虚拟化原理及源代码分析</a></li> </ol> </blockquote> <h2 id="重要数据结构">重要数据结构</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* for KVM_SET_USER_MEMORY_REGION */</span>
<span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">slot</span><span class="p">;</span> <span class="c1">// 要在哪个slot上注册内存区间</span>
  <span class="c1">// flags有两个取值，KVM_MEM_LOG_DIRTY_PAGES和KVM_MEM_READONLY</span>
  <span class="c1">// KVM_MEM_LOG_DIRTY_PAGES用来开启内存脏页</span>
  <span class="c1">// KVM_MEM_READONLY用来开启内存只读。</span>
	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span> 
	<span class="n">__u64</span> <span class="n">guest_phys_addr</span><span class="p">;</span> <span class="c1">// 虚机内存区间起始物理地址</span>
	<span class="n">__u64</span> <span class="n">memory_size</span><span class="p">;</span> <span class="cm">/* bytes */</span> <span class="c1">// 虚机内存区间大小</span>
  <span class="c1">// 虚机内存区间对应的主机虚拟地址</span>
	<span class="n">__u64</span> <span class="n">userspace_addr</span><span class="p">;</span> <span class="cm">/* start of the userspace allocated memory */</span>
<span class="p">};</span>
</code></pre></div></div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">nmemslots</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="n">memslots</span><span class="p">[</span><span class="n">KVM_MEMORY_SLOTS</span> <span class="o">+</span> <span class="n">KVM_PRIVATE_MEM_SLOTS</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div></div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="p">{</span>
	<span class="n">gfn_t</span> <span class="n">base_gfn</span><span class="p">;</span>       <span class="c1">// 该块物理内存块所在guest 物理页帧号</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">;</span> <span class="c1">// 该块物理内存块占用的page数</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rmap</span><span class="p">;</span>  <span class="c1">// 分配该块物理内存对应的host内核虚拟地址（vmalloc分配）</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dirty_bitmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rmap_pde</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">write_count</span><span class="p">;</span>
	<span class="p">}</span> <span class="o">*</span><span class="n">lpage_info</span><span class="p">[</span><span class="n">KVM_NR_PAGE_SIZES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">userspace_addr</span><span class="p">;</span> <span class="c1">// 用户空间地址（QEMU)</span>
	<span class="kt">int</span> <span class="n">user_alloc</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_cr3</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">root</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">get_cr3</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">get_pdptr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">page_fault</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span> <span class="n">u32</span> <span class="n">err</span><span class="p">,</span>
			  <span class="n">bool</span> <span class="n">prefault</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">inject_page_fault</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">fault</span><span class="p">);</span>
	<span class="n">gpa_t</span> <span class="p">(</span><span class="o">*</span><span class="n">gva_to_gpa</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span> <span class="n">u32</span> <span class="n">access</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">);</span>
	<span class="n">gpa_t</span> <span class="p">(</span><span class="o">*</span><span class="n">translate_gpa</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">u32</span> <span class="n">access</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sync_page</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">invlpg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">update_pte</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
			   <span class="n">u64</span> <span class="o">*</span><span class="n">spte</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pte</span><span class="p">);</span>
	<span class="n">hpa_t</span> <span class="n">root_hpa</span><span class="p">;</span>  <span class="c1">// 页表根地址</span>
	<span class="kt">int</span> <span class="n">root_level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shadow_root_level</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">kvm_mmu_page_role</span> <span class="n">base_role</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">direct_map</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>以上数据结构的关系总结为下图：</p> <p><img src="/assets/img/in-post/2023-09-12-mem-virt/struct.jpeg" alt="structure"/></p> <h2 id="ept内存虚拟化代码流程与分析">EPT内存虚拟化代码流程与分析</h2> <p><img src="/assets/img/in-post/2023-09-12-mem-virt/overview.png" alt="截屏2023-09-12 下午3.15.04"/></p> <p>我们可以把硬件辅助的内存虚拟化大致分为四个部分：</p> <ol> <li>建立HVA-GPA的映射关系</li> <li>MMU初始化</li> <li>EPT根页表初始化</li> <li>EPT violation处理</li> </ol> <h3 id="建立gpa-hva的映射关系">建立GPA-HVA的映射关系</h3> <p>这个环节中涉及到的数据结构主要是<code class="language-plaintext highlighter-rouge">kvm_userspace_memory_region</code>和<code class="language-plaintext highlighter-rouge">kvm_memory_slot</code>。HVA-GPA的具体映射信息就保存在<code class="language-plaintext highlighter-rouge">kvm_memory_slot</code>这个结构内。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ioctl</span><span class="p">(</span><span class="n">KVM_SET_USER_MEMORY_REGION</span><span class="p">..)</span>
  <span class="o">--&gt;</span> <span class="n">kvm_vm_ioctl</span> <span class="c1">// kvm-vm匿名设备的ioctl接口的处理函数，分发不同的ioctl</span>
    <span class="o">--&gt;</span><span class="n">kvm_vm_ioctl_set_memory_region</span>  
        <span class="o">--&gt;</span> <span class="n">kvm_set_memory_region</span> 
          <span class="o">--&gt;</span><span class="n">__kvm_set_memory_region</span>   <span class="c1">// 根据用户态提供的信息创建slot</span>
            <span class="o">--&gt;</span> <span class="n">kvm_arch_create_memslot</span>
</code></pre></div></div> <h3 id="mmu初始化">MMU初始化</h3> <p>这个环节主要是设置MMU相关的处理函数，设定内存虚拟化方式（比如是EPT还是SPT），在创建vCPU的时候进行。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ioctl</span><span class="p">(</span><span class="n">KVM_CREATE_CPU</span><span class="p">..)</span>
  <span class="o">--&gt;</span> <span class="n">kvm_vm_ioctl</span> <span class="c1">// kvm-vm匿名设备的ioctl接口的处理函数，分发不同的ioctl</span>
    <span class="o">--&gt;</span><span class="n">kvm_vm_ioctl_create_vcpu</span>  
        <span class="o">--&gt;</span> <span class="n">kvm_arch_vcpu_setup</span> 
          <span class="o">--&gt;</span><span class="n">kvm_mmu_setup</span>  
            <span class="o">--&gt;</span> <span class="n">init_kvm_mmu</span>
  					<span class="c1">// 初始化kvm_mmu结构体</span>
            <span class="c1">// 在这个函数中设定与页表操作相关的各种处理函数，比如发生EPT violation时该调用哪个函数等</span>
  						<span class="o">--&gt;</span> <span class="n">init_kvm_tdp_mmu</span> 
</code></pre></div></div> <h3 id="ept根页表初始化">EPT根页表初始化</h3> <p>对于硬件辅助的内存虚拟化来说，需要设置一个EPT根页表，并将其地址值写入VMCS结构体中，在vCPU运行的时候进行。这样，在进入guest模式时，硬件会自动把EPT根页表地址写入EPTP寄存器中，用于EPT页表映射。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ioctl</span><span class="p">(</span><span class="n">KVM_RUN</span><span class="p">..)</span>
  <span class="o">--&gt;</span> <span class="n">kvm_vcpu_ioctl</span> <span class="c1">// kvm-vm匿名设备的ioctl接口的处理函数，分发不同的ioctl</span>
    <span class="o">--&gt;</span><span class="n">kvm_arch_vcpu_ioctl_run</span>  
        <span class="o">--&gt;</span> <span class="n">vcpu_run</span> 
          <span class="o">--&gt;</span><span class="n">kvm_mmu_reload</span>  
            <span class="o">--&gt;</span> <span class="n">kvm_mmu_load</span>
  						<span class="o">--&gt;</span> <span class="n">mmu_alloc_roots</span> <span class="c1">// 申请EPT根页表内存</span>
  							<span class="o">--&gt;</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">set_cr3</span> <span class="p">(</span><span class="n">vmx_set_cr3</span><span class="p">)</span> <span class="c1">// 在VMCS中设置根页表地址eptp</span>
</code></pre></div></div> <h3 id="ept-violation处理">EPT violation处理</h3> <p>如果在EPT页表中GPA-&gt;HPA的映射不存在，将会触发VM-Exit，KVM负责捕捉该异常，并交由KVM的缺页中断机制进行相应的缺页处理。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vmx_handle_exit</span>
  <span class="o">--&gt;</span> <span class="n">handle_ept_violation</span>
  	<span class="o">--&gt;</span> <span class="n">kvm_mmu_page_fault</span>
  		<span class="o">--&gt;</span> <span class="n">tdp_page_fault</span> <span class="c1">// EPT的缺页处理函数，在MMU初始化的时候设置好的</span>
  			<span class="o">|--&gt;</span> <span class="n">gfn_to_pfn</span>  <span class="c1">// 结合memslot中的信息，以及host内存信息，负责GPA-HPA的转换</span>
  			<span class="o">|--&gt;</span> <span class="n">__direct_map</span> <span class="c1">// 建立EPT页表结构</span>
</code></pre></div></div> <h2 id="具体函数分析">具体函数分析</h2> <p>To Be Continued…</p> <h2 id="reference">Reference</h2> <ol> <li><a href="https://blog.csdn.net/huang987246510/article/details/105744738">QEMU注册内存到KVM流程</a></li> <li><a href="https://oenhan.com/kvm-src-4-mem">KVM源代码分析4:内存虚拟化</a></li> <li><a href="https://royhunter.github.io/2016/03/13/kvm-mmu-virtualization/">KVM之内存虚拟化(KVM MMU Virtualization)</a></li> <li><a href="https://gist.github.com/tan-yue/93acf33f46e1f223b68d0235b563fa79">KVM MMU Note</a></li> <li><a href="https://www.owalle.com/2019/02/20/kvm-src-analysis/">KVM(Kernel-based Virtual Machine)源码分析</a></li> </ol>]]></content><author><name>zxy</name></author><category term="Coding"/><category term="System"/><category term="Virtualization"/><category term="Virtualization"/><summary type="html"><![CDATA[阅读本篇博客前请先阅读 x86内存虚拟化–影子页表(Shadow Page Table)和拓展页表(EPT) Linux KVM x86 CPU虚拟化原理及源代码分析]]></summary></entry><entry><title type="html">Linux KVM x86 CPU虚拟化原理及源代码分析</title><link href="https://zxxyy.github.io/blog/2023/kvm-cpu-virt/" rel="alternate" type="text/html" title="Linux KVM x86 CPU虚拟化原理及源代码分析"/><published>2023-09-11T09:00:00+00:00</published><updated>2023-09-11T09:00:00+00:00</updated><id>https://zxxyy.github.io/blog/2023/kvm-cpu-virt</id><content type="html" xml:base="https://zxxyy.github.io/blog/2023/kvm-cpu-virt/"><![CDATA[<h2 id="硬件辅助的cpu虚拟化">硬件辅助的CPU虚拟化</h2> <p>虚拟化技术允许在一个物理计算机上创建多个虚拟环境，每个虚拟环境都可以独立运行操作系统和应用程序，就像它们在独立的物理计算机上运行一样。硬件辅助的虚拟化技术，顾名思义，就是在CPU、芯片组及I/O等硬件中加入专门针对虚拟化的 支持，使得系统软件更容易、高效地实现虚拟化功能。本篇blog主要介绍x86 VT-x技术对CPU虚拟化的支持。</p> <p>VT-x中的CPU虚拟化主要可以分为三个方面：</p> <ul> <li> <p>引入两种操作模式，统称为VMX操作模式，该模式与Ring0-Ring3的特权级正交</p> <ul> <li>根操作模式（VMX Root Operation）: hypervisor运行所处的模式</li> <li>非根操作模式（VMX Non-Root Operation）：guest/VM运行所处的模式</li> </ul> <p>用QEMU/KVM的例子来说，root和non-root模式以及Ring0-Ring3可以总结为下图：</p> <p>QEMU是运行在根模式下的用户态，为用户提供虚拟化接口。QEMU通过调用KVM提供的API，即<code class="language-plaintext highlighter-rouge">ioctl</code>进入到运行在根模式、内核态下的KVM。KVM通过执行虚拟化相关的特殊指令，将CPU切换到非根模式，运行虚拟机。</p> <p><img src="/assets/img/in-post/2023-09-11-cpu-virt/Kvm_model.png" alt="kvm_model"/></p> </li> <li> <p>引入了VMCS（Virtual-Machine Control Structure），其实就是一块不超过4KB的内存块，用于保存虚拟CPU需要的相关状态。比如CPU在根模式和非根模式下的特权寄存器值，相当于根模式和非根模式的上下文。每个VMCS对应一个虚拟CPU。具体来说，VMCS包括以下五大类别：</p> <ul> <li> <p>Guest State Area</p> <p>这个状态域的主要作用是为了保存客户机运行时的CPU状态。当VM-exit发生时，CPU把当前状态存入客户机状态域；VM-entry发生时，CPU从客户机状态域恢复状态。</p> <p>比如，最简单的情况下，在进入虚拟机前需要设置Guest State Area里的 <code class="language-plaintext highlighter-rouge">RIP</code>的值为虚拟机代码执行开始的位置，这样在VM-entry时，硬件会自动把真实CPU中的RIP的值设置为VMCS中Guest State Area里的RIP值。</p> <p><img src="/assets/img/in-post/2023-09-11-cpu-virt/guest_state_area.png" alt="截屏2023-09-11 下午7.43.53"/></p> </li> <li> <p>Host State Area</p> <p>这个状态域的主要作用是为了CPU在根模式下运行时的CPU状态。因为Host State area的内容通常几乎不变，这个状态域通常只在VM-exit时被恢复，VM-entry时不用保存。</p> <p>比如，简单来说，Host State Area里的 <code class="language-plaintext highlighter-rouge">RIP</code>的值应该设置为VM-exit时VMM的入口地址，也就是虚拟机退出时的异常处理代码的地址。</p> <p><img src="/assets/img/in-post/2023-09-11-cpu-virt/host_state_area.png" alt="截屏2023-09-11 下午7.51.34"/></p> </li> <li> <p>Control Area</p> <p>这个区域用于配制一些虚拟机的执行模式。</p> <p>通过配置该区域，可以指明在虚拟机中执行哪些指令，会引起VM-exit。比如<code class="language-plaintext highlighter-rouge">HLT exiting</code>字段就是控制虚拟机执行HLT指令时是否会发生VM-exit。</p> <p>通过对<code class="language-plaintext highlighter-rouge">Enable EPT</code>位的设置，可以在虚拟化时开启EPT页表内存虚拟化功能。</p> <p><img src="/assets/img/in-post/2023-09-11-cpu-virt/control_area.png" alt="截屏2023-09-11 下午8.00.16"/></p> </li> <li> <p>Vm-exit Control Fields</p> <p>这个区域规定了VM-exit发生时CPU的行为，比如<code class="language-plaintext highlighter-rouge">Host address space size</code>用来指定VM-exit后CPU是否处于64位的模式，64位的VMM通常需要打开这一位。</p> <p><img src="/assets/img/in-post/2023-09-11-cpu-virt/vm-exit-control.png" alt="截屏2023-09-11 下午8.12.36"/></p> </li> <li> <p>Vm-exit Information Fields</p> <p>这个区域用来获取VM-exit时的相关信息，比如是什么原因引起的VM-exit，是执行了<code class="language-plaintext highlighter-rouge">HLT</code>指令还是<code class="language-plaintext highlighter-rouge">EPT violation</code>？通过访问这个字段的信息，我们可以找到VM-exit的原因，并分配不同的处理函数处理这个VM-exit</p> <p><img src="/assets/img/in-post/2023-09-11-cpu-virt/vm-exit-info.png" alt="截屏2023-09-11 下午8.20.37"/></p> </li> </ul> </li> <li> <p>引入了一组新指令，如<code class="language-plaintext highlighter-rouge">vmxon</code>, <code class="language-plaintext highlighter-rouge">vmxoff</code>打开/关闭VMX 操作模式；<code class="language-plaintext highlighter-rouge">vmlaunch</code>, <code class="language-plaintext highlighter-rouge">vmresume</code>发起VM-entry；<code class="language-plaintext highlighter-rouge">vmread</code>, <code class="language-plaintext highlighter-rouge">vmwrite</code>用于配制VMCS结构等等。</p> </li> </ul> <p>​ 在这里，我们通过一张图来表示，这些指令和操作模式之间的关系。</p> <p>​ <img src="/assets/img/in-post/2023-09-11-cpu-virt/root-non-root.png" alt="截屏2023-09-11 下午8.37.17"/></p> <h2 id="qemukvm-cpu虚拟化工作流程">QEMU/KVM CPU虚拟化工作流程</h2> <p>OenHan将KVM的整个工作流程概括为下图：</p> <ol> <li> <p>由虚拟化管理软件Qemu开始启动⼀个虚拟机</p> </li> <li> <p>通过ioctl等系统调⽤向内核中申请指定的资源，搭建好虚拟环境，启动虚拟机内的OS，执⾏ <code class="language-plaintext highlighter-rouge">vmlaunch</code> 指 令，即进⼊了guest代码执⾏过程。</p> <p>对于<code class="language-plaintext highlighter-rouge">ioctl</code>，KVM通过3类不同的文件句柄实现，<code class="language-plaintext highlighter-rouge">kvm-fd</code>,<code class="language-plaintext highlighter-rouge">vm-fd</code>和<code class="language-plaintext highlighter-rouge">vcpu-fd</code>。</p> </li> <li> <p>如果 Guest OS 在⾮根模式下敏感指令引起的 trap，暂停 Guest OS 的执⾏，退出QEMU，即guest VMexit，进⾏⼀些必要的处理，然后重新进⼊客户模式，执⾏guest代码；这个时候如果是io请求，则提交给⽤户态下的qemu处理， qemu模拟处理后再次通过<code class="language-plaintext highlighter-rouge">ioctl</code>反馈给KVM驱动。</p> </li> </ol> <p><img src="/assets/img/in-post/2023-09-11-cpu-virt/kvm_process-1.png" alt="截屏2023-09-11 下午7.43.53"/></p> <h2 id="linux-kvm-cpu虚拟化源码分析">Linux KVM CPU虚拟化源码分析</h2> <h3 id="1-overview">1. Overview</h3> <p>我们首先用思维导图的方式总览Linux KVM kernel module对CPU虚拟化的实现。对于调度和中断的处理我们暂时先不考虑，可以看到KVM实现CPU虚拟化主要分为三步：创建VM，创建VCPU以及VCPU运行。</p> <p><img src="/assets/img/in-post/2023-09-11-cpu-virt/overview.png" alt="overview"/></p> <h3 id="2-主要数据结构">2. 主要数据结构</h3> <p>KVM模块中使用结构体<code class="language-plaintext highlighter-rouge">struct kvm</code>来表示虚拟机，每一个虚拟机实例用一个<code class="language-plaintext highlighter-rouge">struct kvm</code>结构表示。KVM结构体包含了vCPU、内存、APIC、IRQ、MMU、Event事件管理等信息。该结构体中的信息主要在KVM虚拟机内部使用，用于跟踪虚拟机的状态。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">kvm</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">mmu_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">slots_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span> <span class="cm">/* userspace tied to this vm */</span>
	<span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">memslots</span><span class="p">[</span><span class="n">KVM_ADDRESS_SPACE_NUM</span><span class="p">];</span> <span class="cm">/* KVM虚拟机分配的内存slot，用于记录GPA-HVA的映射，内存虚拟化使用 */</span>
	<span class="k">struct</span> <span class="n">srcu_struct</span> <span class="n">srcu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">srcu_struct</span> <span class="n">irq_srcu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpus</span><span class="p">[</span><span class="n">KVM_MAX_VCPUS</span><span class="p">];</span> <span class="cm">/* KVM虚拟机中包含的vCPU结构体，一个虚拟机CPU对应一个vCPU结构体 */</span>
	<span class="n">atomic_t</span> <span class="n">online_vcpus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_boosted_vcpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">vm_list</span><span class="p">;</span> <span class="cm">/* HOST上VM管理链表，multiple "KVM structs"的双向链表 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_io_bus</span> <span class="o">*</span><span class="n">buses</span><span class="p">[</span><span class="n">KVM_NR_BUSES</span><span class="p">];</span> <span class="cm">/* KVM虚拟机中的I/O总线，一条总线对应一个kvm_io_bus结构体，如ISA总线、PCI总线 */</span>
	<span class="k">struct</span> <span class="n">kvm_vm_stat</span> <span class="n">stat</span><span class="p">;</span> <span class="cm">/* KVM虚拟机中的页表、MMU等运行时的状态信息 */</span>
	<span class="k">struct</span> <span class="n">kvm_arch</span> <span class="n">arch</span><span class="p">;</span> <span class="cm">/* 这个是host的arch的一些参数 */</span>
	<span class="n">atomic_t</span> <span class="n">users_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">irq_lock</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">tlbs_dirty</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">devices</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div> <p>每一个vCPU都对应一个kvm_vcpu结构体，在用户通过KVM_CREATE_VCPU系统调用请求创建vCPU时创建。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">;</span> <span class="cm">/* 这个CPU所属的KVM */</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vcpu_id</span><span class="p">;</span> <span class="cm">/* 对应的CPU的ID，由用户进程指定*/</span>
	<span class="kt">int</span> <span class="n">srcu_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">requests</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">guest_debug</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">run</span><span class="p">;</span>  <span class="cm">/* CPU运行时的状态，其中保存了内存信息、虚拟机状态等各种动态信息，如VM-Exit发生的原因等 */</span>
	<span class="kt">int</span> <span class="n">fpu_active</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">guest_fpu_loaded</span><span class="p">,</span> <span class="n">guest_xcr0_loaded</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">fpu_counter</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sigset_active</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">sigset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu_stat</span> <span class="n">stat</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">preempted</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu_arch</span> <span class="n">arch</span><span class="p">;</span> <span class="c1">// 当前VCPU虚拟的架构，存储有KVM虚拟机的运行时参数，如定时器、中断、内存槽等方面的信息</span>
	<span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="3-源码分析">3. 源码分析</h3> <p>有了总体的概念和对主要数据结构的掌握，我们就可以逐一来分析Linux KVM CPU虚拟化的实现了。</p> <h4 id="31-创建vm">3.1 创建VM</h4> <p>创建虚拟机的主体函数是<code class="language-plaintext highlighter-rouge">kvm_create_vm</code>(linux/virt/kvm/kvm_main.c)，用户态Qemu-kvm通过ioctl <code class="language-plaintext highlighter-rouge">KVM_CREATE_VM</code>，经过层层调用，最终进入此函数中，由该函数完成虚拟机的创建。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ioctl</span><span class="p">(</span><span class="n">KVM_CREATE_VM</span><span class="p">..)</span>
  <span class="o">--&gt;</span><span class="n">kvm_dev_ioctl</span>  <span class="c1">// /dev/kvm设备的ioctl接口的处理函数，用于分发不同的ioctl</span>
      <span class="o">--&gt;</span> <span class="n">kvm_dev_ioctl_create_vm</span>  <span class="c1">// 调用kvm_create_vm，并生成kvm-vm的控制文件，用于vm的ioctl</span>
        <span class="o">--&gt;</span><span class="n">kvm_create_vm</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">kvm_dev_ioctl_create_vm</code>的主要流程如下：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// virt/kvm/kvm_main.c: (有所省略)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_dev_ioctl_create_vm</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">;</span>

  <span class="n">kvm</span> <span class="o">=</span> <span class="n">kvm_create_vm</span><span class="p">(</span><span class="n">type</span><span class="p">);</span> 	<span class="cm">/*创建VM*/</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">kvm</span><span class="p">))</span>
         <span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">kvm_coalesced_mmio_init</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">get_unused_fd_flags</span><span class="p">(</span><span class="n">O_CLOEXEC</span><span class="p">);</span>
  <span class="cm">/*生成kvm-vm控制文件，这个文件的作用是提供对vm的io_ctl控制*/</span>
  <span class="n">file</span> <span class="o">=</span> <span class="n">anon_inode_getfile</span><span class="p">(</span><span class="s">"kvm-vm"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm_vm_fops</span><span class="p">,</span> <span class="n">kvm</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
  <span class="p">...</span>
  <span class="n">fd_install</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">kvm_create_vm</code>主要完成KVM虚拟机结构体的创建、KVM的MMU操作接口的安装、KVM的IO总线、事件通道的初始化等操作，主要实现了以下功能：</p> <ol> <li><code class="language-plaintext highlighter-rouge">kvm_arch_alloc_vm()</code>申请并初始化kvm结构体</li> <li><code class="language-plaintext highlighter-rouge">hardware_enable_all()</code>，针对每一个CPU，调用kvm_x86_ops中硬件相关的函数进行硬件使能，主要设置相关寄存器和标记，使CPU进入虚拟化相关模式中(如Intel VMX)。</li> <li>初始化memslots结构体信息</li> <li>初始化BUS总线结构体信息</li> <li>初始化事件通知信息和内存管理相关结构体信息</li> <li>将新创建的虚拟机加入KVM的虚拟机列表</li> </ol> <p>去掉不重要过程以及错误处理路径等，<code class="language-plaintext highlighter-rouge">kvm_create_vm</code>的主要源码如下：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// virt/kvm/kvm_main.c</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="nf">kvm_create_vm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">kvm_arch_alloc_vm</span><span class="p">();</span> <span class="c1">// 申请kvm结构体内存</span>
  <span class="p">...</span>
  <span class="c1">// 调用架构相关的初始化函数，初始化虚拟机</span>
  <span class="c1">// 这部分主要是初始化KVM中类型为kvm_arch的arch成员，用于存放与架构相关的数据</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_init_vm</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span> 
	<span class="p">...</span>
  <span class="c1">// 启用硬件虚拟化支持，主要设置相关寄存器和标记，使CPU进入虚拟化相关模式中</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">hardware_enable_all</span><span class="p">();</span> 
	<span class="p">...</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
  <span class="c1">// 初始化memslots结构体信息</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_ADDRESS_SPACE_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kvm_alloc_memslots</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">out_err_no_srcu</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">...</span>
  <span class="c1">// 初始化BUS总线结构体信息</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_NR_BUSES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">buses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_bus</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">buses</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>
	
  <span class="c1">// 由于虚拟机的内存其实也就是QEMU进程的虚拟内存，因此这里需要引用到当前QEMU进程的mm_struct</span>
  <span class="c1">// 并且初始化mmu_lock成员来表示操作虚拟机MMU数据的锁</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_count</span><span class="p">);</span>
  
  <span class="c1">// 初始化事件通知信息</span>
	<span class="n">kvm_eventfd_init</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">users_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">);</span>
	
  <span class="c1">// 初始化内存管理单元（MMU）通知器，用于跟踪内存的变化</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_init_mmu_notifier</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="p">...</span>
	
  <span class="c1">// 将创建的虚拟机添加到虚拟机列表vm_list中</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">vm_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>

	<span class="n">preempt_notifier_inc</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">kvm</span><span class="p">;</span>

<span class="nl">out_err:</span>
<span class="p">...</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div> <h4 id="32-创建vcpu">3.2 创建vCPU</h4> <p>创建vCPU的主体函数是<code class="language-plaintext highlighter-rouge">kvm_vm_ioctl_create_vcpu</code>(linux/virt/kvm/kvm_main.c)，用户态Qemu通过ioctl <code class="language-plaintext highlighter-rouge">KVM_CREATE_VCPU</code>，经过调用，进入此函数中，由该函数完成vCPU的创建。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ioctl</span><span class="p">(</span><span class="n">KVM_CREATE_VCPU</span><span class="p">..)</span>
  <span class="o">--&gt;</span><span class="n">kvm_vm_ioctl</span>  <span class="c1">// kvm-vm匿名设备的ioctl接口的处理函数，用于分发不同的ioctl</span>
      <span class="o">--&gt;</span> <span class="n">kvm_vm_ioctl_create_vcpu</span>  <span class="c1">// 进行一些错误判断、vcpu_fd创建，调用创建/初始化vCPU的函数</span>
  			<span class="o">--&gt;</span> <span class="n">kvm_arch_vcpu_create</span> <span class="o">&amp;</span> <span class="n">kvm_arch_vcpu_setup</span> <span class="c1">// 创建vCPU的主体函数</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">kvm_vm_ioctl_create_vcpu</code>主要完成kvm_vcpu结构体的创建，包括初始化VMCS等硬件虚拟化结构。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// virt/kvm/kvm_main.c</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_ioctl_create_vcpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
	<span class="cm">/* 判断是否达到最大cpu个数 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">KVM_MAX_VCPUS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/* 调用相关cpu的vcpu_create 通过arch/x86/x86.c 进入vmx.c */</span>
  <span class="cm">/* 创建kvm_vcpu结构体，具体实现跟架构相关，直接调用kvm_x86_ops中的create_cpu方法执行，主要完成相关寄存器和CPUID的初始化 */</span>
	<span class="n">vcpu</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_create</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">preempt_notifier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">preempt_notifier</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm_preempt_ops</span><span class="p">);</span>
	<span class="cm">/* 调用相关cpu的vcpu_setup，初始化kvm_vcpu结构体 */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_setup</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">vcpu_destroy</span><span class="p">;</span>
  

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_vcpu_compatible</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock_vcpu_destroy</span><span class="p">;</span>
	<span class="p">}</span>
  <span class="cm">/* 判断是否达到最大cpu个数，如果是，则销毁刚创建的实例 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">)</span> <span class="o">==</span> <span class="n">KVM_MAX_VCPUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock_vcpu_destroy</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* 判断当前VCPU是否已经加入了某个KVM主机，如果是，则销毁刚创建的实例 */</span>
	<span class="n">kvm_for_each_vcpu</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">kvm</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">vcpu_id</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock_vcpu_destroy</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">vcpus</span><span class="p">[</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">)]);</span>

	<span class="cm">/* Now it's all set up, let userspace reach it */</span>
  <span class="cm">/* 生成kvm-vcpu控制文件，创建vcpu_fd */</span>
	<span class="n">kvm_get_kvm</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">create_vcpu_fd</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_put_kvm</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unlock_vcpu_destroy</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// 将创建的kvm_vcpu结构体加入kvm的VCPU数组中</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">vcpus</span><span class="p">[</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">)]</span> <span class="o">=</span> <span class="n">vcpu</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">);</span> <span class="c1">// 增加online vcpu数量</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">kvm_arch_vcpu_postcreate</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>其中两个主要函数是<code class="language-plaintext highlighter-rouge">kvm_arch_vcpu_create</code>以及<code class="language-plaintext highlighter-rouge">kvm_arch_vcpu_setup</code></p> <ul> <li>在vmx的实现中，<code class="language-plaintext highlighter-rouge">kvm_arch_vcpu_create</code>会调用<code class="language-plaintext highlighter-rouge">vmx_create_vcpu</code>（arch/x86/kvm/vmx.c）函数来创建vCPU。<code class="language-plaintext highlighter-rouge">vmx_create_vcpu</code>会申请VMCS的内存空间，设置VMCS中的状态域、控制域等。为启动虚拟化做好准备。</li> <li>在vmx的实现中，<code class="language-plaintext highlighter-rouge">kvm_arch_vcpu_setup</code>会调用<code class="language-plaintext highlighter-rouge">vcpu_load</code>来使用当前CPU以及<code class="language-plaintext highlighter-rouge">kvm_mmu_setup</code>来设置内存虚拟化相关配置。</li> </ul> <h4 id="33-运行vcpu">3.3 运行VCPU</h4> <p>在VM和VCPU创建好并完成初始化后，就可以调度该VCPU运行了。VCPU(虚拟机)的运行主要任务是要进行上下文切换，主要就是相关寄存器、APIC状态、TLB等。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ioctl</span><span class="p">(</span><span class="n">KVM_RUN</span><span class="p">..)</span>
  <span class="o">--&gt;</span><span class="n">kvm_vcpu_ioctl</span>  <span class="c1">// kvm-vm匿名设备的ioctl接口的处理函数，用于分发不同的ioctl</span>
      <span class="o">--&gt;</span> <span class="n">kvm_arch_vcpu_ioctl_run</span>  
  			<span class="o">--&gt;</span> <span class="n">vcpu_run</span> <span class="c1">// 运行vCPU的主体函数</span>
  				<span class="o">--&gt;</span> <span class="n">vcpu_enter_guest</span>
  					<span class="o">--&gt;</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">run</span> <span class="o">/</span> <span class="n">vmx_vcpu_run</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">vcpu_run</code>的源码如下，分析在注释中，vcpu的主要流程：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">vcpu_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="cm">/* 通过vcpu_enter_guest进入guest模式 */</span> 
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_vcpu_running</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">vcpu_enter_guest</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">vcpu_block</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
    <span class="c1">// 以下是vmexit后的一些处理函数</span>
		<span class="cm">/* 检查是否有阻塞的时钟timer */</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">KVM_REQ_PENDING_TIMER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_cpu_has_pending_timer</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="n">kvm_inject_pending_timer_irqs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="cm">/* 检查是否有用户空间的中断注入 */</span> 
		<span class="k">if</span> <span class="p">(</span><span class="n">dm_request_for_irq_injection</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_INTR</span><span class="p">;</span>
			<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">request_irq_exits</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">kvm_check_async_pf_completion</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="cm">/* 是否有阻塞的signal */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_INTR</span><span class="p">;</span>
			<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">signal_exits</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
    <span class="cm">/* 执行调度 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li> <p><code class="language-plaintext highlighter-rouge">vcpu_enter_guest</code>最终调用kvm_x86_ops中的run函数运行。对应于Intel平台，该函数为<code class="language-plaintext highlighter-rouge">vmx_vcpu_run</code>(设置Guest CR3和其他寄存器、EPT/影子页表相关设置、汇编代码VMLAUNCH切换到非根模式，执行Guest目标代码)。</p> </li> <li> <p>Guest代码执行到敏感指令或因其他原因(比如中断/异常)，VM-Exit退出非根模式，返回到<code class="language-plaintext highlighter-rouge">vcpu_enter_guest</code>函数继续执行。</p> </li> </ul> <h2 id="reference">Reference</h2> <ol> <li> <p><a href="http://liujunming.top/2017/06/27/KVM%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E9%87%8D%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">KVM内核模块重要的数据结构</a></p> </li> <li><a href="http://blog.chinaunix.net/uid-26985337-id-5740797.html">KVM基本原理及架构八-KVM内核模块重要流程分析</a></li> <li><a href="https://xie.infoq.cn/article/6fa43a9b435048e005845e422">QEMU 之 CPU 虚拟化（二）：KVM 模块初始化介绍</a></li> <li> <p><a href="https://juejin.cn/post/7274140856033591348">QEMU之CPU虚拟化（三）：虚拟机的创建</a></p> </li> <li><a href="https://oenhan.com/kvm-src-3-cpu">KVM源代码分析3:CPU虚拟化</a></li> <li> <p><a href="https://www.owalle.com/2019/02/20/kvm-src-analysis/">KVM(Kernel-based Virtual Machine)源码分析</a></p> </li> <li><a href="https://www.owalle.com/2019/02/20/kvm-src-analysis/kvm-src-analysis-mind.svg">KVM思维导图</a></li> <li>《系统虚拟化：原理与实现》</li> </ol>]]></content><author><name>zxy</name></author><category term="Coding"/><category term="System"/><category term="Virtualization"/><category term="Virtualization"/><summary type="html"><![CDATA[硬件辅助的CPU虚拟化]]></summary></entry></feed>