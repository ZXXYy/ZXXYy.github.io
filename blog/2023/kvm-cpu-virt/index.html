<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Linux KVM x86 CPU虚拟化原理及源代码分析 | Xiaoye Zheng </title> <meta name="author" content="Xiaoye Zheng"> <meta name="description" content="Xiaoye Zheng' blog "> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://zxxyy.github.io/blog/2023/kvm-cpu-virt/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Xiaoye</span> Zheng </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Misc </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/books/">Books</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/links/">Links</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Linux KVM x86 CPU虚拟化原理及源代码分析</h1> <p class="post-meta"> Created in September 11, 2023 by zxy </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fa-solid fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/virtualization"> <i class="fa-solid fa-hashtag fa-sm"></i> Virtualization</a>   ·   <a href="/blog/category/coding"> <i class="fa-solid fa-tag fa-sm"></i> Coding</a>   <a href="/blog/category/system"> <i class="fa-solid fa-tag fa-sm"></i> System</a>   <a href="/blog/category/virtualization"> <i class="fa-solid fa-tag fa-sm"></i> Virtualization</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="硬件辅助的cpu虚拟化">硬件辅助的CPU虚拟化</h2> <p>虚拟化技术允许在一个物理计算机上创建多个虚拟环境，每个虚拟环境都可以独立运行操作系统和应用程序，就像它们在独立的物理计算机上运行一样。硬件辅助的虚拟化技术，顾名思义，就是在CPU、芯片组及I/O等硬件中加入专门针对虚拟化的 支持，使得系统软件更容易、高效地实现虚拟化功能。本篇blog主要介绍x86 VT-x技术对CPU虚拟化的支持。</p> <p>VT-x中的CPU虚拟化主要可以分为三个方面：</p> <ul> <li> <p>引入两种操作模式，统称为VMX操作模式，该模式与Ring0-Ring3的特权级正交</p> <ul> <li>根操作模式（VMX Root Operation）: hypervisor运行所处的模式</li> <li>非根操作模式（VMX Non-Root Operation）：guest/VM运行所处的模式</li> </ul> <p>用QEMU/KVM的例子来说，root和non-root模式以及Ring0-Ring3可以总结为下图：</p> <p>QEMU是运行在根模式下的用户态，为用户提供虚拟化接口。QEMU通过调用KVM提供的API，即<code class="language-plaintext highlighter-rouge">ioctl</code>进入到运行在根模式、内核态下的KVM。KVM通过执行虚拟化相关的特殊指令，将CPU切换到非根模式，运行虚拟机。</p> <p><img src="/assets/img/in-post/2023-09-11-cpu-virt/Kvm_model.png" alt="kvm_model"></p> </li> <li> <p>引入了VMCS（Virtual-Machine Control Structure），其实就是一块不超过4KB的内存块，用于保存虚拟CPU需要的相关状态。比如CPU在根模式和非根模式下的特权寄存器值，相当于根模式和非根模式的上下文。每个VMCS对应一个虚拟CPU。具体来说，VMCS包括以下五大类别：</p> <ul> <li> <p>Guest State Area</p> <p>这个状态域的主要作用是为了保存客户机运行时的CPU状态。当VM-exit发生时，CPU把当前状态存入客户机状态域；VM-entry发生时，CPU从客户机状态域恢复状态。</p> <p>比如，最简单的情况下，在进入虚拟机前需要设置Guest State Area里的 <code class="language-plaintext highlighter-rouge">RIP</code>的值为虚拟机代码执行开始的位置，这样在VM-entry时，硬件会自动把真实CPU中的RIP的值设置为VMCS中Guest State Area里的RIP值。</p> <p><img src="/assets/img/in-post/2023-09-11-cpu-virt/guest_state_area.png" alt="截屏2023-09-11 下午7.43.53"></p> </li> <li> <p>Host State Area</p> <p>这个状态域的主要作用是为了CPU在根模式下运行时的CPU状态。因为Host State area的内容通常几乎不变，这个状态域通常只在VM-exit时被恢复，VM-entry时不用保存。</p> <p>比如，简单来说，Host State Area里的 <code class="language-plaintext highlighter-rouge">RIP</code>的值应该设置为VM-exit时VMM的入口地址，也就是虚拟机退出时的异常处理代码的地址。</p> <p><img src="/assets/img/in-post/2023-09-11-cpu-virt/host_state_area.png" alt="截屏2023-09-11 下午7.51.34"></p> </li> <li> <p>Control Area</p> <p>这个区域用于配制一些虚拟机的执行模式。</p> <p>通过配置该区域，可以指明在虚拟机中执行哪些指令，会引起VM-exit。比如<code class="language-plaintext highlighter-rouge">HLT exiting</code>字段就是控制虚拟机执行HLT指令时是否会发生VM-exit。</p> <p>通过对<code class="language-plaintext highlighter-rouge">Enable EPT</code>位的设置，可以在虚拟化时开启EPT页表内存虚拟化功能。</p> <p><img src="/assets/img/in-post/2023-09-11-cpu-virt/control_area.png" alt="截屏2023-09-11 下午8.00.16"></p> </li> <li> <p>Vm-exit Control Fields</p> <p>这个区域规定了VM-exit发生时CPU的行为，比如<code class="language-plaintext highlighter-rouge">Host address space size</code>用来指定VM-exit后CPU是否处于64位的模式，64位的VMM通常需要打开这一位。</p> <p><img src="/assets/img/in-post/2023-09-11-cpu-virt/vm-exit-control.png" alt="截屏2023-09-11 下午8.12.36"></p> </li> <li> <p>Vm-exit Information Fields</p> <p>这个区域用来获取VM-exit时的相关信息，比如是什么原因引起的VM-exit，是执行了<code class="language-plaintext highlighter-rouge">HLT</code>指令还是<code class="language-plaintext highlighter-rouge">EPT violation</code>？通过访问这个字段的信息，我们可以找到VM-exit的原因，并分配不同的处理函数处理这个VM-exit</p> <p><img src="/assets/img/in-post/2023-09-11-cpu-virt/vm-exit-info.png" alt="截屏2023-09-11 下午8.20.37"></p> </li> </ul> </li> <li> <p>引入了一组新指令，如<code class="language-plaintext highlighter-rouge">vmxon</code>, <code class="language-plaintext highlighter-rouge">vmxoff</code>打开/关闭VMX 操作模式；<code class="language-plaintext highlighter-rouge">vmlaunch</code>, <code class="language-plaintext highlighter-rouge">vmresume</code>发起VM-entry；<code class="language-plaintext highlighter-rouge">vmread</code>, <code class="language-plaintext highlighter-rouge">vmwrite</code>用于配制VMCS结构等等。</p> </li> </ul> <p>​ 在这里，我们通过一张图来表示，这些指令和操作模式之间的关系。</p> <p>​ <img src="/assets/img/in-post/2023-09-11-cpu-virt/root-non-root.png" alt="截屏2023-09-11 下午8.37.17"></p> <h2 id="qemukvm-cpu虚拟化工作流程">QEMU/KVM CPU虚拟化工作流程</h2> <p>OenHan将KVM的整个工作流程概括为下图：</p> <ol> <li> <p>由虚拟化管理软件Qemu开始启动⼀个虚拟机</p> </li> <li> <p>通过ioctl等系统调⽤向内核中申请指定的资源，搭建好虚拟环境，启动虚拟机内的OS，执⾏ <code class="language-plaintext highlighter-rouge">vmlaunch</code> 指 令，即进⼊了guest代码执⾏过程。</p> <p>对于<code class="language-plaintext highlighter-rouge">ioctl</code>，KVM通过3类不同的文件句柄实现，<code class="language-plaintext highlighter-rouge">kvm-fd</code>,<code class="language-plaintext highlighter-rouge">vm-fd</code>和<code class="language-plaintext highlighter-rouge">vcpu-fd</code>。</p> </li> <li> <p>如果 Guest OS 在⾮根模式下敏感指令引起的 trap，暂停 Guest OS 的执⾏，退出QEMU，即guest VMexit，进⾏⼀些必要的处理，然后重新进⼊客户模式，执⾏guest代码；这个时候如果是io请求，则提交给⽤户态下的qemu处理， qemu模拟处理后再次通过<code class="language-plaintext highlighter-rouge">ioctl</code>反馈给KVM驱动。</p> </li> </ol> <p><img src="/assets/img/in-post/2023-09-11-cpu-virt/kvm_process-1.png" alt="截屏2023-09-11 下午7.43.53"></p> <h2 id="linux-kvm-cpu虚拟化源码分析">Linux KVM CPU虚拟化源码分析</h2> <h3 id="1-overview">1. Overview</h3> <p>我们首先用思维导图的方式总览Linux KVM kernel module对CPU虚拟化的实现。对于调度和中断的处理我们暂时先不考虑，可以看到KVM实现CPU虚拟化主要分为三步：创建VM，创建VCPU以及VCPU运行。</p> <p><img src="/assets/img/in-post/2023-09-11-cpu-virt/overview.png" alt="overview"></p> <h3 id="2-主要数据结构">2. 主要数据结构</h3> <p>KVM模块中使用结构体<code class="language-plaintext highlighter-rouge">struct kvm</code>来表示虚拟机，每一个虚拟机实例用一个<code class="language-plaintext highlighter-rouge">struct kvm</code>结构表示。KVM结构体包含了vCPU、内存、APIC、IRQ、MMU、Event事件管理等信息。该结构体中的信息主要在KVM虚拟机内部使用，用于跟踪虚拟机的状态。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">kvm</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">mmu_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">slots_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span> <span class="cm">/* userspace tied to this vm */</span>
	<span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">memslots</span><span class="p">[</span><span class="n">KVM_ADDRESS_SPACE_NUM</span><span class="p">];</span> <span class="cm">/* KVM虚拟机分配的内存slot，用于记录GPA-HVA的映射，内存虚拟化使用 */</span>
	<span class="k">struct</span> <span class="n">srcu_struct</span> <span class="n">srcu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">srcu_struct</span> <span class="n">irq_srcu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpus</span><span class="p">[</span><span class="n">KVM_MAX_VCPUS</span><span class="p">];</span> <span class="cm">/* KVM虚拟机中包含的vCPU结构体，一个虚拟机CPU对应一个vCPU结构体 */</span>
	<span class="n">atomic_t</span> <span class="n">online_vcpus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_boosted_vcpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">vm_list</span><span class="p">;</span> <span class="cm">/* HOST上VM管理链表，multiple "KVM structs"的双向链表 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_io_bus</span> <span class="o">*</span><span class="n">buses</span><span class="p">[</span><span class="n">KVM_NR_BUSES</span><span class="p">];</span> <span class="cm">/* KVM虚拟机中的I/O总线，一条总线对应一个kvm_io_bus结构体，如ISA总线、PCI总线 */</span>
	<span class="k">struct</span> <span class="n">kvm_vm_stat</span> <span class="n">stat</span><span class="p">;</span> <span class="cm">/* KVM虚拟机中的页表、MMU等运行时的状态信息 */</span>
	<span class="k">struct</span> <span class="n">kvm_arch</span> <span class="n">arch</span><span class="p">;</span> <span class="cm">/* 这个是host的arch的一些参数 */</span>
	<span class="n">atomic_t</span> <span class="n">users_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">irq_lock</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">tlbs_dirty</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">devices</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div> <p>每一个vCPU都对应一个kvm_vcpu结构体，在用户通过KVM_CREATE_VCPU系统调用请求创建vCPU时创建。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">;</span> <span class="cm">/* 这个CPU所属的KVM */</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vcpu_id</span><span class="p">;</span> <span class="cm">/* 对应的CPU的ID，由用户进程指定*/</span>
	<span class="kt">int</span> <span class="n">srcu_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">requests</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">guest_debug</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">run</span><span class="p">;</span>  <span class="cm">/* CPU运行时的状态，其中保存了内存信息、虚拟机状态等各种动态信息，如VM-Exit发生的原因等 */</span>
	<span class="kt">int</span> <span class="n">fpu_active</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">guest_fpu_loaded</span><span class="p">,</span> <span class="n">guest_xcr0_loaded</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">fpu_counter</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sigset_active</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">sigset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu_stat</span> <span class="n">stat</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">preempted</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu_arch</span> <span class="n">arch</span><span class="p">;</span> <span class="c1">// 当前VCPU虚拟的架构，存储有KVM虚拟机的运行时参数，如定时器、中断、内存槽等方面的信息</span>
	<span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="3-源码分析">3. 源码分析</h3> <p>有了总体的概念和对主要数据结构的掌握，我们就可以逐一来分析Linux KVM CPU虚拟化的实现了。</p> <h4 id="31-创建vm">3.1 创建VM</h4> <p>创建虚拟机的主体函数是<code class="language-plaintext highlighter-rouge">kvm_create_vm</code>(linux/virt/kvm/kvm_main.c)，用户态Qemu-kvm通过ioctl <code class="language-plaintext highlighter-rouge">KVM_CREATE_VM</code>，经过层层调用，最终进入此函数中，由该函数完成虚拟机的创建。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ioctl</span><span class="p">(</span><span class="n">KVM_CREATE_VM</span><span class="p">..)</span>
  <span class="o">--&gt;</span><span class="n">kvm_dev_ioctl</span>  <span class="c1">// /dev/kvm设备的ioctl接口的处理函数，用于分发不同的ioctl</span>
      <span class="o">--&gt;</span> <span class="n">kvm_dev_ioctl_create_vm</span>  <span class="c1">// 调用kvm_create_vm，并生成kvm-vm的控制文件，用于vm的ioctl</span>
        <span class="o">--&gt;</span><span class="n">kvm_create_vm</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">kvm_dev_ioctl_create_vm</code>的主要流程如下：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// virt/kvm/kvm_main.c: (有所省略)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_dev_ioctl_create_vm</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">;</span>

  <span class="n">kvm</span> <span class="o">=</span> <span class="n">kvm_create_vm</span><span class="p">(</span><span class="n">type</span><span class="p">);</span> 	<span class="cm">/*创建VM*/</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">kvm</span><span class="p">))</span>
         <span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">kvm_coalesced_mmio_init</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">get_unused_fd_flags</span><span class="p">(</span><span class="n">O_CLOEXEC</span><span class="p">);</span>
  <span class="cm">/*生成kvm-vm控制文件，这个文件的作用是提供对vm的io_ctl控制*/</span>
  <span class="n">file</span> <span class="o">=</span> <span class="n">anon_inode_getfile</span><span class="p">(</span><span class="s">"kvm-vm"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm_vm_fops</span><span class="p">,</span> <span class="n">kvm</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
  <span class="p">...</span>
  <span class="n">fd_install</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">kvm_create_vm</code>主要完成KVM虚拟机结构体的创建、KVM的MMU操作接口的安装、KVM的IO总线、事件通道的初始化等操作，主要实现了以下功能：</p> <ol> <li> <code class="language-plaintext highlighter-rouge">kvm_arch_alloc_vm()</code>申请并初始化kvm结构体</li> <li> <code class="language-plaintext highlighter-rouge">hardware_enable_all()</code>，针对每一个CPU，调用kvm_x86_ops中硬件相关的函数进行硬件使能，主要设置相关寄存器和标记，使CPU进入虚拟化相关模式中(如Intel VMX)。</li> <li>初始化memslots结构体信息</li> <li>初始化BUS总线结构体信息</li> <li>初始化事件通知信息和内存管理相关结构体信息</li> <li>将新创建的虚拟机加入KVM的虚拟机列表</li> </ol> <p>去掉不重要过程以及错误处理路径等，<code class="language-plaintext highlighter-rouge">kvm_create_vm</code>的主要源码如下：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// virt/kvm/kvm_main.c</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="nf">kvm_create_vm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">kvm_arch_alloc_vm</span><span class="p">();</span> <span class="c1">// 申请kvm结构体内存</span>
  <span class="p">...</span>
  <span class="c1">// 调用架构相关的初始化函数，初始化虚拟机</span>
  <span class="c1">// 这部分主要是初始化KVM中类型为kvm_arch的arch成员，用于存放与架构相关的数据</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_init_vm</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span> 
	<span class="p">...</span>
  <span class="c1">// 启用硬件虚拟化支持，主要设置相关寄存器和标记，使CPU进入虚拟化相关模式中</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">hardware_enable_all</span><span class="p">();</span> 
	<span class="p">...</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
  <span class="c1">// 初始化memslots结构体信息</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_ADDRESS_SPACE_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kvm_alloc_memslots</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">out_err_no_srcu</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">...</span>
  <span class="c1">// 初始化BUS总线结构体信息</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_NR_BUSES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">buses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_bus</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">buses</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>
	
  <span class="c1">// 由于虚拟机的内存其实也就是QEMU进程的虚拟内存，因此这里需要引用到当前QEMU进程的mm_struct</span>
  <span class="c1">// 并且初始化mmu_lock成员来表示操作虚拟机MMU数据的锁</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_count</span><span class="p">);</span>
  
  <span class="c1">// 初始化事件通知信息</span>
	<span class="n">kvm_eventfd_init</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">users_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">);</span>
	
  <span class="c1">// 初始化内存管理单元（MMU）通知器，用于跟踪内存的变化</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_init_mmu_notifier</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="p">...</span>
	
  <span class="c1">// 将创建的虚拟机添加到虚拟机列表vm_list中</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">vm_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>

	<span class="n">preempt_notifier_inc</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">kvm</span><span class="p">;</span>

<span class="nl">out_err:</span>
<span class="p">...</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div> <h4 id="32-创建vcpu">3.2 创建vCPU</h4> <p>创建vCPU的主体函数是<code class="language-plaintext highlighter-rouge">kvm_vm_ioctl_create_vcpu</code>(linux/virt/kvm/kvm_main.c)，用户态Qemu通过ioctl <code class="language-plaintext highlighter-rouge">KVM_CREATE_VCPU</code>，经过调用，进入此函数中，由该函数完成vCPU的创建。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ioctl</span><span class="p">(</span><span class="n">KVM_CREATE_VCPU</span><span class="p">..)</span>
  <span class="o">--&gt;</span><span class="n">kvm_vm_ioctl</span>  <span class="c1">// kvm-vm匿名设备的ioctl接口的处理函数，用于分发不同的ioctl</span>
      <span class="o">--&gt;</span> <span class="n">kvm_vm_ioctl_create_vcpu</span>  <span class="c1">// 进行一些错误判断、vcpu_fd创建，调用创建/初始化vCPU的函数</span>
  			<span class="o">--&gt;</span> <span class="n">kvm_arch_vcpu_create</span> <span class="o">&amp;</span> <span class="n">kvm_arch_vcpu_setup</span> <span class="c1">// 创建vCPU的主体函数</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">kvm_vm_ioctl_create_vcpu</code>主要完成kvm_vcpu结构体的创建，包括初始化VMCS等硬件虚拟化结构。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// virt/kvm/kvm_main.c</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_ioctl_create_vcpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
	<span class="cm">/* 判断是否达到最大cpu个数 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">KVM_MAX_VCPUS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/* 调用相关cpu的vcpu_create 通过arch/x86/x86.c 进入vmx.c */</span>
  <span class="cm">/* 创建kvm_vcpu结构体，具体实现跟架构相关，直接调用kvm_x86_ops中的create_cpu方法执行，主要完成相关寄存器和CPUID的初始化 */</span>
	<span class="n">vcpu</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_create</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">preempt_notifier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">preempt_notifier</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm_preempt_ops</span><span class="p">);</span>
	<span class="cm">/* 调用相关cpu的vcpu_setup，初始化kvm_vcpu结构体 */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_setup</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">vcpu_destroy</span><span class="p">;</span>
  

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_vcpu_compatible</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock_vcpu_destroy</span><span class="p">;</span>
	<span class="p">}</span>
  <span class="cm">/* 判断是否达到最大cpu个数，如果是，则销毁刚创建的实例 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">)</span> <span class="o">==</span> <span class="n">KVM_MAX_VCPUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock_vcpu_destroy</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* 判断当前VCPU是否已经加入了某个KVM主机，如果是，则销毁刚创建的实例 */</span>
	<span class="n">kvm_for_each_vcpu</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">kvm</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">vcpu_id</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock_vcpu_destroy</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">vcpus</span><span class="p">[</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">)]);</span>

	<span class="cm">/* Now it's all set up, let userspace reach it */</span>
  <span class="cm">/* 生成kvm-vcpu控制文件，创建vcpu_fd */</span>
	<span class="n">kvm_get_kvm</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">create_vcpu_fd</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_put_kvm</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unlock_vcpu_destroy</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// 将创建的kvm_vcpu结构体加入kvm的VCPU数组中</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">vcpus</span><span class="p">[</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">)]</span> <span class="o">=</span> <span class="n">vcpu</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">);</span> <span class="c1">// 增加online vcpu数量</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">kvm_arch_vcpu_postcreate</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>其中两个主要函数是<code class="language-plaintext highlighter-rouge">kvm_arch_vcpu_create</code>以及<code class="language-plaintext highlighter-rouge">kvm_arch_vcpu_setup</code></p> <ul> <li>在vmx的实现中，<code class="language-plaintext highlighter-rouge">kvm_arch_vcpu_create</code>会调用<code class="language-plaintext highlighter-rouge">vmx_create_vcpu</code>（arch/x86/kvm/vmx.c）函数来创建vCPU。<code class="language-plaintext highlighter-rouge">vmx_create_vcpu</code>会申请VMCS的内存空间，设置VMCS中的状态域、控制域等。为启动虚拟化做好准备。</li> <li>在vmx的实现中，<code class="language-plaintext highlighter-rouge">kvm_arch_vcpu_setup</code>会调用<code class="language-plaintext highlighter-rouge">vcpu_load</code>来使用当前CPU以及<code class="language-plaintext highlighter-rouge">kvm_mmu_setup</code>来设置内存虚拟化相关配置。</li> </ul> <h4 id="33-运行vcpu">3.3 运行VCPU</h4> <p>在VM和VCPU创建好并完成初始化后，就可以调度该VCPU运行了。VCPU(虚拟机)的运行主要任务是要进行上下文切换，主要就是相关寄存器、APIC状态、TLB等。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ioctl</span><span class="p">(</span><span class="n">KVM_RUN</span><span class="p">..)</span>
  <span class="o">--&gt;</span><span class="n">kvm_vcpu_ioctl</span>  <span class="c1">// kvm-vm匿名设备的ioctl接口的处理函数，用于分发不同的ioctl</span>
      <span class="o">--&gt;</span> <span class="n">kvm_arch_vcpu_ioctl_run</span>  
  			<span class="o">--&gt;</span> <span class="n">vcpu_run</span> <span class="c1">// 运行vCPU的主体函数</span>
  				<span class="o">--&gt;</span> <span class="n">vcpu_enter_guest</span>
  					<span class="o">--&gt;</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">run</span> <span class="o">/</span> <span class="n">vmx_vcpu_run</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">vcpu_run</code>的源码如下，分析在注释中，vcpu的主要流程：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">vcpu_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="cm">/* 通过vcpu_enter_guest进入guest模式 */</span> 
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_vcpu_running</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">vcpu_enter_guest</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">vcpu_block</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
    <span class="c1">// 以下是vmexit后的一些处理函数</span>
		<span class="cm">/* 检查是否有阻塞的时钟timer */</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">KVM_REQ_PENDING_TIMER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_cpu_has_pending_timer</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="n">kvm_inject_pending_timer_irqs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="cm">/* 检查是否有用户空间的中断注入 */</span> 
		<span class="k">if</span> <span class="p">(</span><span class="n">dm_request_for_irq_injection</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_INTR</span><span class="p">;</span>
			<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">request_irq_exits</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">kvm_check_async_pf_completion</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="cm">/* 是否有阻塞的signal */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_INTR</span><span class="p">;</span>
			<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">signal_exits</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
    <span class="cm">/* 执行调度 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li> <p><code class="language-plaintext highlighter-rouge">vcpu_enter_guest</code>最终调用kvm_x86_ops中的run函数运行。对应于Intel平台，该函数为<code class="language-plaintext highlighter-rouge">vmx_vcpu_run</code>(设置Guest CR3和其他寄存器、EPT/影子页表相关设置、汇编代码VMLAUNCH切换到非根模式，执行Guest目标代码)。</p> </li> <li> <p>Guest代码执行到敏感指令或因其他原因(比如中断/异常)，VM-Exit退出非根模式，返回到<code class="language-plaintext highlighter-rouge">vcpu_enter_guest</code>函数继续执行。</p> </li> </ul> <h2 id="reference">Reference</h2> <ol> <li> <p><a href="http://liujunming.top/2017/06/27/KVM%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E9%87%8D%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="external nofollow noopener" target="_blank">KVM内核模块重要的数据结构</a></p> </li> <li><a href="http://blog.chinaunix.net/uid-26985337-id-5740797.html" rel="external nofollow noopener" target="_blank">KVM基本原理及架构八-KVM内核模块重要流程分析</a></li> <li><a href="https://xie.infoq.cn/article/6fa43a9b435048e005845e422" rel="external nofollow noopener" target="_blank">QEMU 之 CPU 虚拟化（二）：KVM 模块初始化介绍</a></li> <li> <p><a href="https://juejin.cn/post/7274140856033591348" rel="external nofollow noopener" target="_blank">QEMU之CPU虚拟化（三）：虚拟机的创建</a></p> </li> <li><a href="https://oenhan.com/kvm-src-3-cpu" rel="external nofollow noopener" target="_blank">KVM源代码分析3:CPU虚拟化</a></li> <li> <p><a href="https://www.owalle.com/2019/02/20/kvm-src-analysis/" rel="external nofollow noopener" target="_blank">KVM(Kernel-based Virtual Machine)源码分析</a></p> </li> <li><a href="https://www.owalle.com/2019/02/20/kvm-src-analysis/kvm-src-analysis-mind.svg" rel="external nofollow noopener" target="_blank">KVM思维导图</a></li> <li>《系统虚拟化：原理与实现》</li> </ol> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/solana-concepts/">Solana Core Concepts: Accounts, Programs, and PDAs</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/python-asyncio/">Python3 Concurrency: asyncio module/async/await</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/python-cheat-sheet/">Python Cheat Sheet</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/raft-leader/">MIT6.824 Lab2A Raft Leader Election</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/top/">Linux中的top command</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Xiaoye Zheng. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"About",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"Blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-publications",title:"Publications",description:"",section:"Navigation",handler:()=>{window.location.href="/publications/"}},{id:"nav-repositories",title:"Repositories",description:"",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"dropdown-books",title:"Books",description:"",section:"Dropdown",handler:()=>{window.location.href=""}},{id:"dropdown-links",title:"Links",description:"",section:"Dropdown",handler:()=>{window.location.href=""}},{id:"post-solana-core-concepts-accounts-programs-and-pdas",title:"Solana Core Concepts: Accounts, Programs, and PDAs",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/solana-concepts/"}},{id:"post-python3-concurrency-asyncio-module-async-await",title:"Python3 Concurrency: asyncio module/async/await",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/python-asyncio/"}},{id:"post-python-cheat-sheet",title:"Python Cheat Sheet",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/python-cheat-sheet/"}},{id:"post-mit6-824-lab2a-raft-leader-election",title:"MIT6.824 Lab2A Raft Leader Election",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/raft-leader/"}},{id:"post-linux\u4e2d\u7684top-command",title:"Linux\u4e2d\u7684top command",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/top/"}},{id:"post-arm\u4ea4\u53c9\u7f16\u8bd1\u5de5\u5177\u94fe\u4e0e\u7f16\u8bd1\u9009\u9879",title:"ARM\u4ea4\u53c9\u7f16\u8bd1\u5de5\u5177\u94fe\u4e0e\u7f16\u8bd1\u9009\u9879",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/cross-compile/"}},{id:"post-mit6-824-lab1-map-reduce",title:"MIT6.824 Lab1 Map Reduce",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/map-reduce/"}},{id:"post-\u4f7f\u7528gcov-lcov\u6d4b\u8bd5\u7528\u4f8b\u7684\u4ee3\u7801\u8986\u76d6\u7387",title:"\u4f7f\u7528gcov/lcov\u6d4b\u8bd5\u7528\u4f8b\u7684\u4ee3\u7801\u8986\u76d6\u7387",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/gcov/"}},{id:"post-rust\u7f16\u8bd1\u5668\u521d\u63a2-rust\u7f16\u8bd1\u5668\u662f\u5982\u4f55\u5de5\u4f5c\u7684",title:"rust\u7f16\u8bd1\u5668\u521d\u63a2\uff1aRust\u7f16\u8bd1\u5668\u662f\u5982\u4f55\u5de5\u4f5c\u7684",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/rustc/"}},{id:"post-linux-kvm-x86\u5185\u5b58\u865a\u62df\u5316ept\u6e90\u4ee3\u7801\u5206\u6790",title:"Linux KVM x86\u5185\u5b58\u865a\u62df\u5316EPT\u6e90\u4ee3\u7801\u5206\u6790",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/kvm-mem-source/"}},{id:"post-linux-kvm-x86-cpu\u865a\u62df\u5316\u539f\u7406\u53ca\u6e90\u4ee3\u7801\u5206\u6790",title:"Linux KVM x86 CPU\u865a\u62df\u5316\u539f\u7406\u53ca\u6e90\u4ee3\u7801\u5206\u6790",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/kvm-cpu-virt/"}},{id:"post-\u8ba9google\u641c\u7d22\u5230\u4f60\u7684github\u7f51\u9875-\u4f7f\u7528jekyll\u642d\u5efa",title:"\u8ba9Google\u641c\u7d22\u5230\u4f60\u7684Github\u7f51\u9875\uff08\u4f7f\u7528Jekyll\u642d\u5efa\uff09",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/add-Google-search/"}},{id:"post-x86\u5185\u5b58\u865a\u62df\u5316-\u5f71\u5b50\u9875\u8868-shadow-page-table-\u548c\u62d3\u5c55\u9875\u8868-ept",title:"x86\u5185\u5b58\u865a\u62df\u5316--\u5f71\u5b50\u9875\u8868(Shadow Page Table)\u548c\u62d3\u5c55\u9875\u8868(EPT)",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/SPT-EPT/"}},{id:"post-rust\u88f8\u6307\u9488-\u5f15\u7528-slice-box-vec-string\u7684\u5185\u5b58\u5e03\u5c40\u53ca\u8f6c\u6362",title:"Rust\u88f8\u6307\u9488,\u5f15\u7528,slice,box,vec,string\u7684\u5185\u5b58\u5e03\u5c40\u53ca\u8f6c\u6362",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/rust-type-mem-layout/"}},{id:"post-virtualization-tools-overwiew-for-layman",title:"Virtualization Tools Overwiew for Layman",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/virtualization-tools/"}},{id:"post-rust-cheat-sheet-in-practice",title:"Rust Cheat Sheet in Practice",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/rust-cheat-sheet/"}},{id:"post-\u7ebf\u5f62-\u975e\u7ebf\u5f62\u964d\u7ef4\u65b9\u6cd5\u6982\u8ff0",title:"\u7ebf\u5f62/\u975e\u7ebf\u5f62\u964d\u7ef4\u65b9\u6cd5\u6982\u8ff0",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/dim-reduction/"}},{id:"post-qemu-kvm\u4e2d\u7684\u7f51\u7edc\u865a\u62df\u5316-part2-user-networking",title:"QEMU/KVM\u4e2d\u7684\u7f51\u7edc\u865a\u62df\u5316--Part2 User Networking",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/qemu-network-slirp/"}},{id:"post-qemu-kvm-rust\u76f8\u5173\u5165\u95e8\u8d44\u6e90\u6574\u7406",title:"QEMU/KVM Rust\u76f8\u5173\u5165\u95e8\u8d44\u6e90\u6574\u7406",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/kvm-101/"}},{id:"post-qemu-kvm\u4e2d\u7684\u7f51\u7edc\u865a\u62df\u5316-part1-overview",title:"QEMU/KVM\u4e2d\u7684\u7f51\u7edc\u865a\u62df\u5316--Part1 Overview",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/qemu-network/"}},{id:"post-meltdown\u539f\u7406\u53caseed-lab\u5b9e\u9a8csetup",title:"Meltdown\u539f\u7406\u53caSEED Lab\u5b9e\u9a8csetup",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/meltdown/"}},{id:"post-frp-learning-notes\u53ca\u76f8\u5173\u914d\u7f6e\u64cd\u4f5c",title:"frp learning notes\u53ca\u76f8\u5173\u914d\u7f6e\u64cd\u4f5c",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/frp/"}},{id:"post-adaboosting-learning-notes",title:"AdaBoosting Learning notes",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/AdaBoosting/"}},{id:"post-\u533a\u522barm\u4e0b\u7684armv9-a32-aarch64-cortex",title:"\u533a\u522bARM\u4e0b\u7684Armv9, A32, AArch64, Cortex...",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/ARM_architect/"}},{id:"post-gdb\u5165\u95e8-\u5e38\u7528\u6307\u4ee4-\u811a\u672c-\u63d2\u4ef6",title:"GDB\u5165\u95e8\uff1a\u5e38\u7528\u6307\u4ee4\u3001\u811a\u672c\u3001\u63d2\u4ef6",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/gdb_command/"}},{id:"post-ds-store\u662f\u4ec0\u4e48-\u600e\u4e48\u5220\u9664",title:".DS_store\u662f\u4ec0\u4e48\uff1f\u600e\u4e48\u5220\u9664\uff1f",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/DS_store/"}},{id:"post-jekyll-learning-notes",title:"Jekyll Learning Notes",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/jekyll/"}},{id:"post-useful-websites-amp-shortcuts",title:"Useful Websites & shortcuts",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/useful-web/"}},{id:"post-support-vector-machine-svm-learning-notes",title:"Support Vector Machine (SVM) Learning notes",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2023/SVM/"}},{id:"news-a-simple-inline-announcement",title:"A simple inline announcement.",description:"",section:"News"},{id:"news-a-long-announcement-with-details",title:"A long announcement with details",description:"",section:"News",handler:()=>{window.location.href="/news/announcement_2/"}},{id:"news-a-simple-inline-announcement-with-markdown-emoji-sparkles-smile",title:'A simple inline announcement with Markdown emoji! <img class="emoji" title=":sparkles:" alt=":sparkles:" src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png" height="20" width="20"> <img class="emoji" title=":smile:" alt=":smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png" height="20" width="20">',description:"",section:"News"},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%78%69%61%6F%79%65%7A@%7A%6A%75.%65%64%75.%63%6E","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=LJFW4ZIAAAAJ","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/ZXXYy","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>